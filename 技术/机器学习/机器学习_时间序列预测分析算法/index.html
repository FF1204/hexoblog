<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/hexoblog/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/hexoblog/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/hexoblog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/hexoblog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/hexoblog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexoblog/hexoblog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/hexoblog/hexoblog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/hexoblog/hexoblog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/hexoblog/hexoblog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="时间序列,">





  <link rel="alternate" href="/hexoblog/atom.xml" title="FEIFEI" type="application/atom+xml">






<meta name="description" content="预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。">
<meta name="keywords" content="时间序列">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习_时间序列预测分析算法">
<meta property="og:url" content="http://FF1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/index.html">
<meta property="og:site_name" content="FEIFEI">
<meta property="og:description" content="预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ff1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/2017-05-11_172946.png">
<meta property="og:image" content="http://ff1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/2017-05-11_191517.png">
<meta property="og:image" content="http://ff1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/2017-05-11_192035.png">
<meta property="og:image" content="http://ff1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/2017-05-11_193546.png">
<meta property="og:image" content="http://ff1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/2017-05-11_193854.png">
<meta property="og:updated_time" content="2019-08-01T02:24:50.586Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机器学习_时间序列预测分析算法">
<meta name="twitter:description" content="预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。">
<meta name="twitter:image" content="http://ff1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/2017-05-11_172946.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/hexoblog/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://FF1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/">





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "c0ad732b"
    });
  daovoice('update');
  </script>


  <title>机器学习_时间序列预测分析算法 | FEIFEI</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/hexoblog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FEIFEI</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/hexoblog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/hexoblog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/hexoblog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://FF1204.github.io/hexoblog/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FEI FEI">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/hexoblog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FEIFEI">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">机器学习_时间序列预测分析算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-11T16:08:13+08:00">
                2017-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexoblog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexoblog/categories/技术/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>预测问题是机器学习中很重要的一个问题，它是根据过去已经存在的数据预测未来可能的情况。本文通过一个著名的波士顿抢劫案的数据集来说明预测问题的来龙去脉。</p>
<a id="more"></a>
<h2 id="AR自回归模型预测"><a href="#AR自回归模型预测" class="headerlink" title="AR自回归模型预测"></a>AR自回归模型预测</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><a href="https://datamarket.com/data/set/235k/daily-total-female-births-in-california-1959#!ds=235k&amp;display=line" target="_blank" rel="noopener">Daily Female Births Dataset</a></p>
<p>This dataset describes the number of daily female births in California in 1959.</p>
<p>它的结构很简单，每一行是一天的数据，每一行有两个数据，第一个是日期，第二个是人数。</p>
<h3 id="用Python加载数据集"><a href="#用Python加载数据集" class="headerlink" title="用Python加载数据集"></a>用Python加载数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line">file_path = <span class="string">r'D:\deeplearning\Forecasting\daily-total-female-births-in-cal.csv'</span></span><br><span class="line">series = Series.from_csv(file_path, header=<span class="number">0</span>)</span><br><span class="line">print(series.head())</span><br><span class="line">series.plot()</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
<p>series.plot()是pandas的Series自己提供的数据可视化方法。</p>
<h3 id="选择一种预测模型"><a href="#选择一种预测模型" class="headerlink" title="选择一种预测模型"></a>选择一种预测模型</h3><p>这里我们先选择使用最广泛的自回归模型来看看。</p>
<h4 id="Autoregressive-model"><a href="#Autoregressive-model" class="headerlink" title="Autoregressive model"></a>Autoregressive model</h4><p>自回归模型（英语：Autoregressive model，简称AR模型），是统计上一种处理时间序列的方法，用同一变数例如x的之前各期，亦即$x_1$至 $ x_{t-1}$来预测本期 $x_$ 的表现，并假设它们为一线性关系。因为这是从回归分析中的线性回归发展而来，只是不用x预测y，而是用x预测x（自己）；所以叫做自回归。<br>自回归模型被广泛运用在经济学、信息学、自然现象的预测上.</p>
<p>自回归模型（Autoregressive Model）是用自身做回归变量的过程，即利用前期若干时刻的随机变量的线性组合来描述以后某时刻随机变量的线性回归模型，它是时间序列中的一种常见形式.</p>
<p>P阶自回归模型，记作AR(p),含义是序列中$x_t$是前p个序列$(x_{t-6},x_{t-5},x_{t-4},x_{t-3},x_{t-2},x_{t-1})$ 和误差项通过线性组合而成的。</p>
<p><strong>优点与限制</strong></p>
<ol>
<li>必须具有自相关，自相关系数（$\varphi _{i}$）是关键。如果自相关系数(R)小于0.5，则不宜采用，否则预测结果极不准确。</li>
<li>自回归只能适用于预测与自身前期相关的经济现象，即受自身历史因素影响较大的经济现象，如矿的开采量，各种自然资源产量等；对于受社会因素影响较大的经济现象，不宜采用自回归，而应改采可纳入其他变数的向量自回归模型。</li>
</ol>
<h4 id="使用AR模型的训练和测试"><a href="#使用AR模型的训练和测试" class="headerlink" title="使用AR模型的训练和测试"></a>使用AR模型的训练和测试</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面该选择用来预测的模型了，</span></span><br><span class="line"><span class="comment"># 这里我们随便选择一个 AR 模型</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.ar_model <span class="keyword">import</span> AR</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a difference transform of the dataset</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">difference</span><span class="params">(dataset)</span>:</span></span><br><span class="line">	diff = list()</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(dataset)):</span><br><span class="line">		value = dataset[i] - dataset[i - <span class="number">1</span>]</span><br><span class="line">		diff.append(value)</span><br><span class="line">	<span class="keyword">return</span> numpy.array(diff)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a prediction give regression coefficients and lag obs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(coef, history)</span>:</span></span><br><span class="line">	yhat = coef[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(coef)):</span><br><span class="line">		yhat += coef[i] * history[-i]</span><br><span class="line">	<span class="keyword">return</span> yhat</span><br><span class="line"></span><br><span class="line"><span class="comment"># split dataset</span></span><br><span class="line">X = difference(series.values)</span><br><span class="line">size = int(len(X) * <span class="number">0.66</span>)</span><br><span class="line">train, test = X[<span class="number">0</span>:size], X[size:]</span><br><span class="line"><span class="comment"># train autoregression</span></span><br><span class="line">model = AR(train)</span><br><span class="line">model_fit = model.fit(maxlag=<span class="number">6</span>, disp=<span class="literal">False</span>)</span><br><span class="line">window = model_fit.k_ar</span><br><span class="line">coef = model_fit.params</span><br><span class="line"><span class="comment"># walk forward over time steps in test</span></span><br><span class="line">history = [train[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(train))]</span><br><span class="line">predictions = list()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(len(test)):</span><br><span class="line">	yhat = predict(coef, history)</span><br><span class="line">	obs = test[t]</span><br><span class="line">	predictions.append(yhat)</span><br><span class="line">	history.append(obs)</span><br><span class="line">error = mean_squared_error(test, predictions)</span><br><span class="line">print(<span class="string">'Test MSE: %.3f'</span> % error)</span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">pyplot.plot(test)</span><br><span class="line">pyplot.plot(predictions, color=<span class="string">'red'</span>)</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
<p>上面我们使用的是AR(6)模型。就是用前6个数据去预测第七个数据。如此循环，不断调整参数，减小损失函数。</p>
<p><img src="2017-05-11_172946.png" alt></p>
<p>保存训练好的模型，以便以后的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save model to file</span></span><br><span class="line">model_fit.save(<span class="string">'ar_model.pkl'</span>)</span><br><span class="line"><span class="comment"># save the differenced dataset</span></span><br><span class="line">numpy.save(<span class="string">'ar_data.npy'</span>, X)</span><br><span class="line"><span class="comment"># save the last ob</span></span><br><span class="line">numpy.save(<span class="string">'ar_obs.npy'</span>, [series.values[<span class="number">-1</span>]])</span><br></pre></td></tr></table></figure>
<p>与之对应的加载模型的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load the AR model from file</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.ar_model <span class="keyword">import</span> ARResults</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">loaded = ARResults.load(<span class="string">'ar_model.pkl'</span>)</span><br><span class="line">print(loaded.params)</span><br><span class="line">data = numpy.load(<span class="string">'ar_data.npy'</span>)</span><br><span class="line">last_ob = numpy.load(<span class="string">'ar_obs.npy'</span>)</span><br><span class="line">print(last_ob)</span><br></pre></td></tr></table></figure>
<h2 id="线性回归预测"><a href="#线性回归预测" class="headerlink" title="线性回归预测"></a>线性回归预测</h2><h2 id="使用神经网络实现简单的线性回归"><a href="#使用神经网络实现简单的线性回归" class="headerlink" title="使用神经网络实现简单的线性回归"></a>使用神经网络实现简单的线性回归</h2><h3 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h3><p>The problem that we will look at in this tutorial is the <a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data" target="_blank" rel="noopener">Boston house price dataset</a>.</p>
<p>The dataset describes 13 numerical properties of houses in Boston suburbs and is concerned with modeling the price of houses in those suburbs in thousands of dollars. As such, this is a regression predictive modeling problem. Input attributes include things like crime rate, proportion of nonretail business acres, chemical concentrations and more.</p>
<p><a href="http://www.cs.toronto.edu/~delve/data/boston/bostonDetail.html" target="_blank" rel="noopener">数据集的详细说明</a></p>
<h3 id="使用keras用简单的神经网络模拟线性回归"><a href="#使用keras用简单的神经网络模拟线性回归" class="headerlink" title="使用keras用简单的神经网络模拟线性回归"></a>使用keras用简单的神经网络模拟线性回归</h3><p>我们使用<a href="https://keras.io/" target="_blank" rel="noopener">Keras</a>构造一个简单的全连接的神经网络来模拟回归模型，做出预测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Thu May 11 14:44:12 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> pandas</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.wrappers.scikit_learn <span class="keyword">import</span> KerasRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># load dataset</span></span><br><span class="line">data_file_path = <span class="string">r'D:\deeplearning\Boston house price dataset\housing.data.txt'</span></span><br><span class="line">dataframe = pandas.read_csv(data_file_path, delim_whitespace=<span class="literal">True</span>, header=<span class="literal">None</span>)</span><br><span class="line">dataset = dataframe.values</span><br><span class="line"><span class="comment"># split into input (X) and output (Y) variables</span></span><br><span class="line">X = dataset[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = dataset[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># create model</span></span><br><span class="line">  <span class="comment"># 该模型一共有三层，第一层是输入，有13个神经元；第二层是也有13个神经元，激活函数是relu</span></span><br><span class="line">  <span class="comment"># 第三层只有一个神经元，是输出，没有激活函数</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">13</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br><span class="line">	<span class="comment"># Compile model</span></span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 划分训练集和测试集</span></span><br><span class="line">x_train = X[<span class="number">0</span>:<span class="number">400</span>,:]</span><br><span class="line">x_test = X[<span class="number">400</span>:,:]</span><br><span class="line">y_train = Y[<span class="number">0</span>:<span class="number">400</span>]</span><br><span class="line">y_test = Y[<span class="number">400</span>:]</span><br><span class="line">model.fit(x_train,y_train,epochs=<span class="number">1000</span>,batch_size=<span class="number">10</span>,shuffle=<span class="literal">True</span>,)</span><br><span class="line">predicted_y = model.predict(x_test)</span><br><span class="line">print(y_test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line">pyplot.plot(predicted_y)</span><br><span class="line">pyplot.plot(y_test, color=<span class="string">'red'</span>)</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure>
<p>epochs = 1000 的时候的结果：</p>
<p><img src="2017-05-11_191517.png" alt></p>
<p>epochs = 1500 的时候的结果：</p>
<p><img src="2017-05-11_192035.png" alt></p>
<p>我们可以借助keara提供的scikit-learn API来和scikit-learn互动，这样我们可以更加方便的使用scikit-learn实现的交叉验证方式来测试我们的神经网络。</p>
<p>首先，我们把定义神经网络模型的代码写成函数的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define base model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseline_model</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># create model</span></span><br><span class="line">	model = Sequential()</span><br><span class="line">	model.add(Dense(<span class="number">13</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">	model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br><span class="line">	<span class="comment"># Compile model</span></span><br><span class="line">	model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=<span class="string">'adam'</span>)</span><br><span class="line">	<span class="keyword">return</span> mode</span><br></pre></td></tr></table></figure>
<p>我们使用KerasRegressor来打通和scikit-learn的连接。’nb_epoch=100, batch_size=5, verbose=0’这些参数都是kears模型fit的时候需要的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># evaluate model with standardized dataset</span></span><br><span class="line">estimator = KerasRegressor(build_fn=baseline_model, nb_epoch=<span class="number">100</span>, batch_size=<span class="number">5</span>, verbose=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>K折交叉验证和结果的评估：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state=seed)</span><br><span class="line">results = cross_val_score(estimator, X, Y, cv=kfold)</span><br><span class="line">print(<span class="string">"Results: %.2f (%.2f) MSE"</span> % (results.mean(), results.std()))</span><br></pre></td></tr></table></figure>
<p>为了方便理解和描述，我们这里只是介绍一下交叉验证的实现方法，并不使用。我们还是使用上面完整一段代码里用的手工划分训练集和测试集的方法。</p>
<h3 id="神经网络结构的调整和性能的比较"><a href="#神经网络结构的调整和性能的比较" class="headerlink" title="神经网络结构的调整和性能的比较"></a>神经网络结构的调整和性能的比较</h3><p>我们改变一下上面定义的神经网络的结构，看结果是不是会发生变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dense(<span class="number">13</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">6</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br></pre></td></tr></table></figure>
<p>原来的结构是<code>13 inputs -&gt;13 -&gt; 1</code>, 现在变成了<code>13 inputs -&gt; 13 -&gt; 6 -&gt; 1</code>. epochs = 1000 得到的结果是：</p>
<p><img src="2017-05-11_193546.png" alt></p>
<p>可以看到并没有太大的提高。我们再尝试使用更多的隐层神经元试试。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">20</span>, input_dim=<span class="number">13</span>, kernel_initializer=<span class="string">'normal'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">'normal'</span>))</span><br></pre></td></tr></table></figure>
<p><img src="2017-05-11_193854.png" alt></p>
<p>还是没有太大的提高，估计这种简单的模型也只能是这个水平了。</p>
<p>参考资料：<a href="http://machinelearningmastery.com/regression-tutorial-keras-deep-learning-library-python/" target="_blank" rel="noopener">http://machinelearningmastery.com/regression-tutorial-keras-deep-learning-library-python/</a></p>
<p> 参考文献：</p>
<ol>
<li><p><a href="http://machinelearningmastery.com/make-predictions-time-series-forecasting-python" target="_blank" rel="noopener">http://machinelearningmastery.com/make-predictions-time-series-forecasting-python</a></p>
</li>
<li><p><a href="http://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras" target="_blank" rel="noopener">http://machinelearningmastery.com/time-series-prediction-lstm-recurrent-neural-networks-python-keras</a></p>
</li>
<li><p><a href="http://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python" target="_blank" rel="noopener">http://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python</a></p>
</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/hexoblog/images/weixin.png" alt="FEI FEI 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/hexoblog//images/alipay.png" alt="FEI FEI 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    FEI FEI
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://FF1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/" title="机器学习_时间序列预测分析算法">http://FF1204.github.io/hexoblog/技术/机器学习/机器学习_时间序列预测分析算法/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/hexoblog/tags/时间序列/" rel="tag"># 时间序列</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/hexoblog/技术/数据结构和算法/算法专题_计算几何/" rel="next" title="算法专题_计算几何">
                <i class="fa fa-chevron-left"></i> 算法专题_计算几何
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/hexoblog/技术/认知神经科学/使用3D卷积神经神经网络提取脑成像数据的特征/" rel="prev" title="使用3D卷积神经神经网络提取脑成像数据的特征">
                使用3D卷积神经神经网络提取脑成像数据的特征 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">FEI FEI</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/hexoblog/archives/">
              
                  <span class="site-state-item-count">162</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">101</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/hexoblog/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/FF1204" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#AR自回归模型预测"><span class="nav-number">1.</span> <span class="nav-text">AR自回归模型预测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据集"><span class="nav-number">1.1.</span> <span class="nav-text">数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用Python加载数据集"><span class="nav-number">1.2.</span> <span class="nav-text">用Python加载数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择一种预测模型"><span class="nav-number">1.3.</span> <span class="nav-text">选择一种预测模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Autoregressive-model"><span class="nav-number">1.3.1.</span> <span class="nav-text">Autoregressive model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用AR模型的训练和测试"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用AR模型的训练和测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性回归预测"><span class="nav-number">2.</span> <span class="nav-text">线性回归预测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用神经网络实现简单的线性回归"><span class="nav-number">3.</span> <span class="nav-text">使用神经网络实现简单的线性回归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据集-1"><span class="nav-number">3.1.</span> <span class="nav-text">数据集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用keras用简单的神经网络模拟线性回归"><span class="nav-number">3.2.</span> <span class="nav-text">使用keras用简单的神经网络模拟线性回归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#神经网络结构的调整和性能的比较"><span class="nav-number">3.3.</span> <span class="nav-text">神经网络结构的调整和性能的比较</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2011 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FEI FEI</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">231.7k</span>
  
</div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/hexoblog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/hexoblog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/hexoblog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/hexoblog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexoblog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/hexoblog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/hexoblog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/hexoblog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexoblog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/hexoblog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/hexoblog/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/hexoblog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/hexoblog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/hexoblog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/hexoblog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
