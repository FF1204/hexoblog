<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FEIFEI</title>
  
  
  <link href="/hexoblog/atom.xml" rel="self"/>
  
  <link href="http://FF1204.github.io/hexoblog/"/>
  <updated>2019-08-01T02:24:50.490Z</updated>
  <id>http://FF1204.github.io/hexoblog/</id>
  
  <author>
    <name>FEI FEI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo博客配置攻略</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/%E9%85%8D%E7%BD%AEHexo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://FF1204.github.io/hexoblog/技术/工具/Hexo/配置Hexo自动部署/</id>
    <published>2019-06-16T23:29:08.000Z</published>
    <updated>2019-08-01T02:24:50.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><p><strong>站点配置文件</strong>位于：<code>hexoblog/_config.yml</code></p></li><li><p><strong>主题配置文件</strong>位于：<code>hexoblog/themes/theme_name/_config.yml</code></p></li><li><p><strong>安装依赖</strong> : 在<code>hexoblog/package.json</code>中添加要安装的依赖，然后在站点根目录执行<code>npm install</code></p></li><li><p><strong>自定义站点配置文件</strong> : 使用<code>--config config_file.yml</code>可以使用自己定义的站点配置文件启动</p></li></ul><a id="more"></a><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><blockquote><p>要实现的功能</p><ul><li>博客源代码托管在Github平台和Gitee平台</li><li>利用Github, Gitee的Pages服务托管生成的HTML网页</li><li>每当提交到Github的时候触发自动构建，自动生成Hexo博客部署到Github和Gitee</li><li>Github和Gitee部署不同主题的网页</li></ul></blockquote><p>代码托管网站使用<a href>Github</a>和<a href>Gitee</a>, 二者都提供<code>Pages</code>服务。自动构建工具选择<a href>travis</a>, 它可以自动关联到Github中的仓库上。</p><p>我本地博客路径为<code>hexoblog</code>, Github仓库为<code>hexoblog</code>, 共有两个分支，<code>hexo</code>为主分支，托管博客源码, <code>master</code>为<code>pages</code>分支，托管博客生成的HTML文件。 Gitee的布局和Github一样，也有一个<code>hexoblog</code>仓库，两个分支。我在Github上部署主题为wikitten的博客，在Gitee上部署主题为next的博客。</p><p>要实现上述功能，只需要配置好几个配置文件就可以了。</p><p>在站点根目录新增<code>.travis.yml</code>文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">language: node_js # 编译语言、环境</span><br><span class="line"></span><br><span class="line">sudo: required # 需要管理员权限</span><br><span class="line"></span><br><span class="line">dist: trusty # 指定 CI 系统版本为 Ubuntu16.04 LTS</span><br><span class="line"></span><br><span class="line">node_js: </span><br><span class="line">    - '8' #Node.js 版本</span><br><span class="line"></span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - hexo # 只有hexo分支检出更改才触发CI</span><br><span class="line"></span><br><span class="line">before_install: </span><br><span class="line">  - export TZ='Asia/Shanghai' #配置时区为东八区UTC+8</span><br><span class="line">  - npm install hexo-cli &gt; /dev/null # 安装 hexo</span><br><span class="line">  - git config user.name $GIT_NAME</span><br><span class="line">  - git config user.email $GIT_EMAIL</span><br><span class="line">  - sed -i'' "s~xxx_gitee_xxx~$&#123;GITEE_TOKEN&#125;~" _config.next.yml # 配置部署用到的TOKEN</span><br><span class="line">  - sed -i'' "s~xxx_github_xxx~$&#123;GITHUB_TOKEN&#125;~" _config.wikitten.yml</span><br><span class="line"><span class="meta">  #</span><span class="bash">  - sudo apt-get install libpng16-dev <span class="comment"># 安装 libpng16-dev CI编译出现相关报错时请取消注释</span></span></span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - npm install # 安装依赖</span><br><span class="line"></span><br><span class="line">script: # 执行脚本，清除缓存，生成静态文件</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo g -d --config _config.next.yml</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo g -d --config _config.wikitten.yml</span><br></pre></td></tr></table></figure><p>以上脚本是travis自动构建需要读取的脚本，里面使用的GIT_NAME, GIT_EMAIL, GITEE_TOKEN, GITHUB_TOKEN是环境变量，可以在travis的网站中配置具体的值，如果你不介意暴露这些信息，也可以直接写具体的值。</p><p><code>xxx_gitee_xxx</code> 是占位符，<code>sed -i&#39;&#39; &quot;s~xxx_gitee_xxx~${GITEE_TOKEN}~&quot; _config.next.yml</code>的含义是替换<code>_config.next.yml</code>中的<code>xxx_gitee_xxx</code>为在travis网站中设置的环境变量GITEE_TOKEN, 这样可以避免自己的密码暴露在脚本中。Github 和 Gitee 生成 Token的方法可以参考官方文档。</p><p><code>hexo g -d --config _config.next.yml</code>是使用<code>_config.next.yml</code>生成网站并部署，通过使用这样的命令，我们可以生成多个主题的网站。</p><p>复制<strong>站点配置文件</strong>重命名为<code>_config.next.yml</code>并修改如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br><span class="line"># theme: Wikitten</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://FF1204:xxx_gitee_xxx@gitee.com/FF1204/hexoblog.git</span><br><span class="line">    branch: master</span><br><span class="line">    message: travis-ci commit</span><br></pre></td></tr></table></figure><p>指定主题为<code>next</code>主题，deploy 为部署到Giteee的hexoblog仓库的master分支。</p><p>复制<strong>站点配置文件</strong>重命名为<code>_config.wikitten.yml</code>并修改如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">theme: Wikitten</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://xxx_github_xxx@github.com/FF1204/hexoblog.git</span><br><span class="line">    branch: master</span><br><span class="line">    message: travis-ci commit</span><br></pre></td></tr></table></figure><p>指定主题为<code>Wikitten</code>主题，deploy 为部署到 Github 的 hexoblog 仓库的 master 分支。</p><p>使用Github账号登陆travis网站，打开hexoblog仓库的自动构建选项，即可开始自动构建。(上面提到的主题的安装可以搜索对应的官网)</p><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><p>熟悉主题的构造之后，可以直接更改主题文件实现一些主题本来不具备的功能。</p><h3 id="添加聊天功能"><a href="#添加聊天功能" class="headerlink" title="添加聊天功能"></a>添加聊天功能</h3><p>DaoVoice提供了一个功能不错的在线聊天功能，只需要到网站中添加一段代码，便可生成一个聊天图标，你使用微信便可以直接和浏览你网页的人互动。</p><p>注册Daovice网站，开通自己的账户，你会获得自己的一段代码和一个appid.</p><p>以next主题为例，在themes/next/layout/_partials/head.swig最后添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&apos;init&apos;, &#123;</span><br><span class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&apos;update&apos;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>然后在next的主题配置文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Online contact</span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: xxxxxx</span><br></pre></td></tr></table></figure><p>把注册账户的时候获得的app_id填在配置文件中。</p><h3 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h3><p>安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>在<code>hexoblog/themes/next/layout/_partials/footer.swig</code>尾部添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h2><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p>next 是一个极简的主题，使用人数多，教程丰富，各种DIY非常多，建议使用这个主题，有问题容易解决，而且现在还在更新。</p><h3 id="wikitten"><a href="#wikitten" class="headerlink" title="wikitten"></a>wikitten</h3><p>Wikitten是一个可以自动按照文件夹层次分类的主题，而且展示的时候也是按照文件夹的层次分类展示的，比较符合我的多级分类的需要。</p><h3 id="Maupassant"><a href="#Maupassant" class="headerlink" title="Maupassant"></a>Maupassant</h3><p>非常简单的一个模板，简单到渣，但是很优秀</p><h2 id="hexo-博客推荐"><a href="#hexo-博客推荐" class="headerlink" title="hexo 博客推荐"></a>hexo 博客推荐</h2><p>推荐一些值得参考的博客样例。</p><ul><li>next 主题配置大全：<a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">https://www.jianshu.com/p/f054333ac9e6</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;站点配置文件&lt;/strong&gt;位于：&lt;code&gt;hexoblog/_config.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;主题配置文件&lt;/strong&gt;位于：&lt;code&gt;hexoblog/themes/theme_name/_config.yml&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装依赖&lt;/strong&gt; : 在&lt;code&gt;hexoblog/package.json&lt;/code&gt;中添加要安装的依赖，然后在站点根目录执行&lt;code&gt;npm install&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;自定义站点配置文件&lt;/strong&gt; : 使用&lt;code&gt;--config config_file.yml&lt;/code&gt;可以使用自己定义的站点配置文件启动&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Hexo" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Hexo/"/>
    
    
      <category term="hexo" scheme="http://FF1204.github.io/hexoblog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>蜡烛图技术</title>
    <link href="http://FF1204.github.io/hexoblog/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/%E8%9C%A1%E7%83%9B%E5%9B%BE%E6%8A%80%E6%9C%AF/"/>
    <id>http://FF1204.github.io/hexoblog/经济学原理/蜡烛图技术/</id>
    <published>2019-04-18T00:18:04.000Z</published>
    <updated>2019-08-01T02:24:50.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蜡烛图技术"><a href="#蜡烛图技术" class="headerlink" title="蜡烛图技术"></a>蜡烛图技术</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>蜡烛图是由一个矩形，上线各一个出头的直线组成，矩形的上下两端表示开盘价和收盘价，矩形的高度表示开盘价和收盘价的差距大小，向上伸出的线表示最高成交价格，向下伸出的线表示最低的成交价格。所以绘制一根蜡烛线需要4个数据：开盘价，收盘价，最高价，最低价。</p><p>一般用红色实心矩形表示收盘价格高于开盘价格，也就是价格上涨了。</p><p>一般用黑色实心矩形表示收盘价格高于开盘价格，也就是价格下跌了。</p><a id="more"></a><h2 id="形态"><a href="#形态" class="headerlink" title="形态"></a>形态</h2><p>形态是指多根蜡烛线组成的各种图形所表现出来的某种规律性的东西。</p><h3 id="锤子线和上吊线"><a href="#锤子线和上吊线" class="headerlink" title="锤子线和上吊线"></a>锤子线和上吊线</h3><p>锤子线和上吊线的形状是一样的，只是出现的位置不同。当出现在连续下降的一系列蜡烛线之后的时候，叫做锤子线，表明下降已经到底，之后很可能会上升；当出现在连续上升的一系列蜡烛线之后的时候，叫做上吊线，表明上涨的行情即将结束，之后很可能会下降。</p><p>识别标准：</p><ol><li>实体处于整个价格区间的上端。而实体本身的颜色是无所谓的。</li><li>下影线的长度至少达到实体高度的 2 倍。</li><li>在这类蜡烛线中，应当没有上影线，即使有上影线，其长度也是极短的</li></ol><p>下影线的长度是实体的两倍，上影线没有或者很短很短，形状很像一个长柄的锤子。</p><p>验证信号：</p><p>上吊线实体与第二天的开盘价向下的缺口（实际上就是第二天开盘价格比前一天下降的越多）越大，上吊线越有可能是市场的顶部(意思就是之后会下跌)， 如果在上吊线之后，市场形成了黑色的实体，并且其收盘价低于上吊线的收盘价，也是上吊线成立的强有力的佐证。</p><p>分析：</p><p>锤子线和上吊线的形态说明当日的最高价十分接近开盘价或者收盘价，也就是在交易的一天中没有突破的动力，而下探的动力却很强（下影线是实体的两倍），对于锤子线，下探这么多还能返回到之前的水平收盘，本身有看涨的意味；对于上吊线，之前一直在上涨，而这次下探这么多，很可能是要下降的信号。而如果上吊线第二天的开盘价格低于前一天的收盘价格，表示确实下降了，上吊线得到了验证，这个时候市场上会看这种趋势的人也很多，就会抛售股票，导致股票价格下降。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;蜡烛图技术&quot;&gt;&lt;a href=&quot;#蜡烛图技术&quot; class=&quot;headerlink&quot; title=&quot;蜡烛图技术&quot;&gt;&lt;/a&gt;蜡烛图技术&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;蜡烛图是由一个矩形，上线各一个出头的直线组成，矩形的上下两端表示开盘价和收盘价，矩形的高度表示开盘价和收盘价的差距大小，向上伸出的线表示最高成交价格，向下伸出的线表示最低的成交价格。所以绘制一根蜡烛线需要4个数据：开盘价，收盘价，最高价，最低价。&lt;/p&gt;
&lt;p&gt;一般用红色实心矩形表示收盘价格高于开盘价格，也就是价格上涨了。&lt;/p&gt;
&lt;p&gt;一般用黑色实心矩形表示收盘价格高于开盘价格，也就是价格下跌了。&lt;/p&gt;
    
    </summary>
    
      <category term="经济学原理" scheme="http://FF1204.github.io/hexoblog/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>地点链接记忆法</title>
    <link href="http://FF1204.github.io/hexoblog/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/%E5%9C%B0%E7%82%B9%E9%93%BE%E6%8E%A5%E8%AE%B0%E5%BF%86%E6%B3%95/"/>
    <id>http://FF1204.github.io/hexoblog/心理学/记忆魔法/地点链接记忆法/</id>
    <published>2019-04-08T22:54:47.000Z</published>
    <updated>2019-08-01T02:24:50.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地点链接记忆法"><a href="#地点链接记忆法" class="headerlink" title="地点链接记忆法"></a>地点链接记忆法</h1><p>把要记忆的事情固定在自己熟悉的几个地点上，实质产生荒谬的联想画面，从而按顺序记忆。<br>之所以能按顺序，是因为熟悉的地点是有顺序的，并且自己已经记住了他们的顺序。</p><a id="more"></a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href></a></li><li><a href></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;地点链接记忆法&quot;&gt;&lt;a href=&quot;#地点链接记忆法&quot; class=&quot;headerlink&quot; title=&quot;地点链接记忆法&quot;&gt;&lt;/a&gt;地点链接记忆法&lt;/h1&gt;&lt;p&gt;把要记忆的事情固定在自己熟悉的几个地点上，实质产生荒谬的联想画面，从而按顺序记忆。&lt;br&gt;之所以能按顺序，是因为熟悉的地点是有顺序的，并且自己已经记住了他们的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="心理学" scheme="http://FF1204.github.io/hexoblog/categories/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="记忆魔法" scheme="http://FF1204.github.io/hexoblog/categories/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/"/>
    
    
      <category term="记忆" scheme="http://FF1204.github.io/hexoblog/tags/%E8%AE%B0%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>代码记忆法</title>
    <link href="http://FF1204.github.io/hexoblog/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BF%86%E6%B3%95/"/>
    <id>http://FF1204.github.io/hexoblog/心理学/记忆魔法/代码记忆法/</id>
    <published>2019-04-03T14:51:32.000Z</published>
    <updated>2019-08-01T02:24:50.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码记忆法"><a href="#代码记忆法" class="headerlink" title="代码记忆法"></a>代码记忆法</h1><p>使用英语单词对数字编码，强化记忆数字和编码之间的关系，就可以把数字转换成对应的英语单词，而英语单词是有意义的，可以转化成画面，运用画面辅助记忆，可以达到快速记忆的目的。这就是代码记忆法的思路。</p><a id="more"></a><h2 id="数字编码方法"><a href="#数字编码方法" class="headerlink" title="数字编码方法"></a>数字编码方法</h2><p>来自布拉德·乔伊斯（美）的超级记忆力训练</p><h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><p><img src="zero.jpg" alt="Z, S"></p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><img src="tie.jpg" alt="T,D,tie,领带"></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><img src="noah.jpg" alt="N, noah, 诺亚方舟"></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><img src="ma.jpg" alt="M, ma, 妈妈"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><img src="rye.jpg" alt="R, rye, 燕麦"></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><img src="law.jpg" alt="L, law, 法律"></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><img src="shoe.jpg" alt="sh, shoe, 鞋子"></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><img src="cow.jpg" alt="K,C, cow, 奶牛"></p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p><img src="ivy.jpg" alt="V, ivy, 常春藤"></p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p><img src="bee.jpg" alt="B,P, bee, 蜜蜂"></p><p>0 到9都有了代表它们的发音字母和具体的实物，接下来为10 到 99 设置对应的代表实物，方法是分解成单个数字，然后组合。</p><p>例如：</p><p>10 由 1 和 0 组成， 所以代表10的单词应该包含T或者D，且包含Z或者S，找一个满足这个条件的单词，我们使用toes这个单词。</p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p><img src="toes.jpg" alt="toes, 脚趾"></p><h3 id="11-–-99"><a href="#11-–-99" class="headerlink" title="11 – 99"></a>11 – 99</h3><table><thead><tr><th>数字</th><th>单词</th><th>含义</th><th>自己想象画面</th></tr></thead><tbody><tr><td>11</td><td>tot</td><td>小孩</td><td></td></tr><tr><td>12</td><td>tin</td><td>罐头</td><td></td></tr><tr><td>13</td><td>tomb</td><td>坟墓</td><td></td></tr><tr><td>14</td><td>tire</td><td>轮胎</td><td></td></tr><tr><td>15</td><td>towel</td><td>毛巾</td><td></td></tr><tr><td>16</td><td>dish</td><td>盘子</td><td></td></tr><tr><td>17</td><td>tack</td><td>大头针</td><td></td></tr><tr><td>18</td><td>dove</td><td>鸽子</td><td></td></tr><tr><td>19</td><td>tub</td><td>浴盆</td><td></td></tr><tr><td>20</td><td>nose</td><td>鼻子</td><td></td></tr><tr><td>21</td><td>net</td><td>网</td><td></td></tr><tr><td>22</td><td>nun</td><td>修女</td><td></td></tr><tr><td>23</td><td>name</td><td>名字</td><td></td></tr><tr><td>24</td><td>nero</td><td>罗马暴君尼禄</td><td></td></tr><tr><td>25</td><td>nail</td><td>指甲</td><td></td></tr><tr><td>26</td><td>notch</td><td>东非大裂谷</td><td></td></tr><tr><td>27</td><td>neck</td><td>脖子</td><td></td></tr><tr><td>28</td><td>knife</td><td>刀子</td><td></td></tr><tr><td>29</td><td>knob</td><td>球形把手</td><td></td></tr><tr><td>30</td><td>mice</td><td>老鼠</td><td></td></tr><tr><td>31</td><td>mat</td><td>席子</td><td></td></tr><tr><td>32</td><td>moon</td><td>月亮</td><td></td></tr><tr><td>33</td><td>mummy</td><td>木乃伊</td><td></td></tr><tr><td>34</td><td>mower</td><td>割草机</td><td></td></tr><tr><td>35</td><td>mule</td><td>骡子</td><td></td></tr><tr><td>36</td><td>match</td><td>火柴</td><td></td></tr><tr><td>37</td><td>mug</td><td>大杯子</td><td></td></tr><tr><td>38</td><td>movie</td><td>电影</td><td></td></tr><tr><td>39</td><td>mop</td><td>拖把</td><td></td></tr><tr><td>40</td><td>rose</td><td>玫瑰</td><td></td></tr><tr><td>41</td><td>rod</td><td>杆子</td><td></td></tr><tr><td>42</td><td>rain</td><td>雨水</td><td></td></tr><tr><td>43</td><td>ram</td><td>公羊</td><td></td></tr><tr><td>44</td><td>rower</td><td>划船的人</td><td></td></tr><tr><td>45</td><td>roll</td><td>面包卷</td><td></td></tr><tr><td>46</td><td>roach</td><td>螳螂</td><td></td></tr><tr><td>47</td><td>rock</td><td>岩石</td><td></td></tr><tr><td>48</td><td>roof</td><td>房顶</td><td></td></tr><tr><td>49</td><td>rope</td><td>绳子</td><td></td></tr><tr><td>50</td><td>lace</td><td>鞋带</td><td></td></tr><tr><td>51</td><td>loft</td><td>阁楼</td><td></td></tr><tr><td>52</td><td>lining</td><td>衣服衬里</td><td></td></tr><tr><td>53</td><td>lamp</td><td>灯</td><td></td></tr><tr><td>54</td><td>liner</td><td>班船，班机</td><td></td></tr><tr><td>55</td><td>lily</td><td>百合花、睡莲</td><td></td></tr><tr><td>56</td><td>lunch</td><td>午餐</td><td></td></tr><tr><td>57</td><td>leak</td><td>漏水</td><td></td></tr><tr><td>58</td><td>love</td><td>热爱</td><td></td></tr><tr><td>59</td><td>lobby</td><td>前厅、门廊</td><td></td></tr><tr><td>60</td><td>shoes</td><td>鞋子</td><td></td></tr><tr><td>61</td><td>shuttle</td><td>梭</td><td></td></tr><tr><td>62</td><td>shrine</td><td>圣地</td><td></td></tr><tr><td>63</td><td>shame</td><td>羞辱</td><td></td></tr><tr><td>64</td><td>shower</td><td>下阵雨</td><td></td></tr><tr><td>65</td><td>shell</td><td>炮弹</td><td></td></tr><tr><td>66</td><td>shush</td><td>嘘，别出声</td><td></td></tr><tr><td>67</td><td>shark</td><td>鲨鱼</td><td></td></tr><tr><td>68</td><td>shove</td><td>推开</td><td></td></tr><tr><td>69</td><td>shrub</td><td>灌木丛</td><td></td></tr><tr><td>70</td><td>case</td><td>例子</td><td></td></tr><tr><td>71</td><td>cat</td><td>猫</td><td></td></tr><tr><td>72</td><td>can</td><td>罐头</td><td></td></tr><tr><td>73</td><td>kame</td><td>小沙丘</td><td></td></tr><tr><td>74</td><td>car</td><td>小汽车</td><td></td></tr><tr><td>75</td><td>cell</td><td>细胞</td><td></td></tr><tr><td>76</td><td>cash</td><td>现金</td><td></td></tr><tr><td>77</td><td>kick</td><td>踢</td><td></td></tr><tr><td>78</td><td>cave</td><td>地窖</td><td></td></tr><tr><td>79</td><td>cap</td><td>帽子</td><td></td></tr><tr><td>80</td><td>voice</td><td>嗓音</td><td></td></tr><tr><td>81</td><td>void</td><td>空</td><td></td></tr><tr><td>82</td><td>vine</td><td>葡萄树</td><td></td></tr><tr><td>83</td><td>vim</td><td>文本编辑器</td><td></td></tr><tr><td>84</td><td>VR</td><td>虚拟现实设备</td><td></td></tr><tr><td>85</td><td>wheel</td><td>轮子</td><td></td></tr><tr><td>86</td><td>witch</td><td>女巫</td><td></td></tr><tr><td>87</td><td>weak</td><td>虚弱的</td><td></td></tr><tr><td>88</td><td>wave</td><td>海浪</td><td></td></tr><tr><td>89</td><td>web</td><td>蜘蛛网</td><td></td></tr><tr><td>90</td><td>boss</td><td>老板</td><td></td></tr><tr><td>91</td><td>boot</td><td>长靴</td><td></td></tr><tr><td>92</td><td>born</td><td>出生</td><td></td></tr><tr><td>93</td><td>beam</td><td>光线</td><td></td></tr><tr><td>94</td><td>bear</td><td>熊</td><td></td></tr><tr><td>95</td><td>blue</td><td>蓝色</td><td></td></tr><tr><td>96</td><td>bitch</td><td>母狗</td><td></td></tr><tr><td>97</td><td>bug</td><td>虫子</td><td></td></tr><tr><td>98</td><td>buffer</td><td>缓冲区</td><td></td></tr><tr><td>99</td><td>babby</td><td>年龄最小的人</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码记忆法&quot;&gt;&lt;a href=&quot;#代码记忆法&quot; class=&quot;headerlink&quot; title=&quot;代码记忆法&quot;&gt;&lt;/a&gt;代码记忆法&lt;/h1&gt;&lt;p&gt;使用英语单词对数字编码，强化记忆数字和编码之间的关系，就可以把数字转换成对应的英语单词，而英语单词是有意义的，可以转化成画面，运用画面辅助记忆，可以达到快速记忆的目的。这就是代码记忆法的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="心理学" scheme="http://FF1204.github.io/hexoblog/categories/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="记忆魔法" scheme="http://FF1204.github.io/hexoblog/categories/%E5%BF%83%E7%90%86%E5%AD%A6/%E8%AE%B0%E5%BF%86%E9%AD%94%E6%B3%95/"/>
    
    
      <category term="记忆" scheme="http://FF1204.github.io/hexoblog/tags/%E8%AE%B0%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey非常有用的脚本</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/AutoHotKey/AutoHotKey%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://FF1204.github.io/hexoblog/技术/工具/AutoHotKey/AutoHotKey非常有用的脚本/</id>
    <published>2018-12-02T09:42:38.000Z</published>
    <updated>2019-08-01T02:24:50.490Z</updated>
    
    <content type="html"><![CDATA[<p>键盘和鼠标按键修改工具AutoHotKey可以实现修改任意键盘按键和鼠标按键的功能，可以实现快捷短语的输入。</p><a id="more"></a><p>我的AutoHotKey脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br></pre></td><td class="code"><pre><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">;***********************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                 使用键盘模拟鼠标                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock+d         |    开启                     ||</span><br><span class="line">;||      CapsLock+f         |    关闭                     ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||        d                |    左键                     ||</span><br><span class="line">;||        f                |    右键                     ||</span><br><span class="line">;||      ikjl               |    鼠标移动                 ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">#SingleInstance</span><br><span class="line">count = 0</span><br><span class="line">JoyMultiplier = 0.20</span><br><span class="line">JoyThreshold = 3</span><br><span class="line">JoyThresholdUpper := 50 + JoyThresholdr</span><br><span class="line">JoyThresholdLower := 50 - JoyThreshold</span><br><span class="line">YAxisMultiplier = -1</span><br><span class="line">SetTimer, WatchKeyboard, 20</span><br><span class="line">Hotkey, d, ButtonRight</span><br><span class="line">Hotkey, f, ButtonLeft</span><br><span class="line">Hotkey, i,empty</span><br><span class="line">Hotkey, k,empty</span><br><span class="line">Hotkey, j,empty</span><br><span class="line">Hotkey, l,empty</span><br><span class="line">Hotkey, u,empty</span><br><span class="line">Hotkey, m,empty</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; d::</span><br><span class="line">    SetTimer, WatchKeyboard,On</span><br><span class="line">    Hotkey, d, on</span><br><span class="line">    Hotkey, f, on</span><br><span class="line">    Hotkey, i, on</span><br><span class="line">    Hotkey, k, on</span><br><span class="line">    Hotkey, j, on</span><br><span class="line">    Hotkey, l, on</span><br><span class="line">Hotkey, u, on</span><br><span class="line">Hotkey, m, on</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; f::</span><br><span class="line">    SetTimer, WatchKeyboard, Off</span><br><span class="line">    Hotkey, d, Off</span><br><span class="line">    Hotkey, f, Off</span><br><span class="line">    Hotkey, i, Off</span><br><span class="line">    Hotkey, k, Off</span><br><span class="line">    Hotkey, j, Off</span><br><span class="line">    Hotkey, l, Off</span><br><span class="line">Hotkey, u, off</span><br><span class="line">Hotkey, m, off</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">empty:</span><br><span class="line">Return</span><br><span class="line">WatchKeyboard:</span><br><span class="line">MouseNeedsToBeMoved := false  ; Set default.</span><br><span class="line">JoyMultiplier+=0.01</span><br><span class="line">SetFormat, float, 03</span><br><span class="line">i:=GetKeyState(&quot;i&quot;,&quot;p&quot;)</span><br><span class="line">k:=GetKeyState(&quot;k&quot;,&quot;p&quot;)</span><br><span class="line">j:=GetKeyState(&quot;j&quot;,&quot;p&quot;)</span><br><span class="line">l:=GetKeyState(&quot;l&quot;,&quot;p&quot;)</span><br><span class="line">u:=GetKeyState(&quot;u&quot;,&quot;p&quot;)</span><br><span class="line">m:=GetKeyState(&quot;m&quot;,&quot;p&quot;)</span><br><span class="line">if(u)</span><br><span class="line">&#123;</span><br><span class="line">send,&#123;WheelUp&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(m)</span><br><span class="line">&#123;</span><br><span class="line">send,&#123;WheelDown&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(l)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaX := 10</span><br><span class="line">&#125;</span><br><span class="line">else if(j)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">BeMoved := true</span><br><span class="line">    DeltaX := -10</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    DeltaX = 0</span><br><span class="line">if (i)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaY := 10</span><br><span class="line">&#125;</span><br><span class="line">else if (k)</span><br><span class="line">&#123;</span><br><span class="line">    MouseNeedsToBeMoved := true</span><br><span class="line">    DeltaY := -10</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">    DeltaY = 0</span><br><span class="line">if MouseNeedsToBeMoved</span><br><span class="line">&#123;</span><br><span class="line">    SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">    MouseMove, DeltaX * JoyMultiplier, DeltaY * JoyMultiplier * YAxisMultiplier, 0, R</span><br><span class="line">&#125;</span><br><span class="line">Else</span><br><span class="line">count++</span><br><span class="line">If(count&gt;20)&#123;</span><br><span class="line">JoyMultiplier = 0.30</span><br><span class="line">count=0</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">ButtonLeft:</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, left,,, 1, 0, D  ; Hold down the left mouse button.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">ButtonRight:</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, right,,, 1, 0, D  ; Hold down the right mouse button.</span><br><span class="line">SetTimer, WaitForRightButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WaitForLeftButtonUp:</span><br><span class="line">if GetKeyState(&quot;f&quot;)</span><br><span class="line">    return  ; The button is still, down, so keep waiting.</span><br><span class="line">; Otherwise, the button has been released.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, off</span><br><span class="line">SetMouseDelay, -1  ; Makes movement smoother.</span><br><span class="line">MouseClick, left,,, 1, 0, U  ; Release the mouse button.</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">WaitForRightButtonUp:</span><br><span class="line">if GetKeyState(&quot;d&quot;)</span><br><span class="line">    return  ; The button is still, down, so keep waiting.</span><br><span class="line">; Otherwise, the button has been released.</span><br><span class="line">SetTimer, WaitForRightButtonUp, off</span><br><span class="line">MouseClick, right,,, 1, 0, U  ; Release the mouse button.</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                 使用键盘模拟鼠标                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      a+f                |    左键                     ||</span><br><span class="line">;||      a+d                |    右键                     ||</span><br><span class="line">;||      a+u                |    向上滚轮                 ||</span><br><span class="line">;||      a+m                |    向下滚轮                 ||</span><br><span class="line">;||      a+i,j,k,l          |    鼠标移动                 ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">$a::</span><br><span class="line">Send, a</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; i::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, 0, -15, 0, R </span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; k::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, 0, 15, 0, R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; j::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseMove, -15, 0, 0, R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; l::</span><br><span class="line">SetMouseDelay, -1</span><br><span class="line">MouseMove 15 ,0,0,R</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; u::</span><br><span class="line">Send, &#123;WheelUp&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; m::</span><br><span class="line">Send, &#123;WheelDown&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; f::</span><br><span class="line">SetMouseDelay, -1  </span><br><span class="line">MouseClick, left,,, 1, 0, D  ; Hold down the left mouse button.</span><br><span class="line">SetTimer, WaitForLeftButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">a &amp; d::</span><br><span class="line">SetMouseDelay, -1 </span><br><span class="line">MouseClick, right,,, 1, 0, D  ; Hold down the right mouse button.</span><br><span class="line">SetTimer, WaitForRightButtonUp, 10</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                CapsLock改成Enter键                    ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CaspLock                |    Enter               ||</span><br><span class="line">;||      alt + CapsLock          |    CaspLock            ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">$CapsLock::Enter </span><br><span class="line"></span><br><span class="line">LAlt &amp; CapsLock::</span><br><span class="line">GetKeyState, CapsLockState, CapsLock, T</span><br><span class="line">if CapsLockState = D</span><br><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">else</span><br><span class="line">SetCapsLockState, AlwaysOn</span><br><span class="line">KeyWait, CapsLock </span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">RAlt &amp; CapsLock::</span><br><span class="line">GetKeyState, CapsLockState, CapsLock, T</span><br><span class="line">if CapsLockState = D</span><br><span class="line">SetCapsLockState, AlwaysOff</span><br><span class="line">else</span><br><span class="line">SetCapsLockState, AlwaysOn</span><br><span class="line">KeyWait, CapsLock </span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                主键盘增加方向键                       ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CaspLock + i       |    Up                       ||</span><br><span class="line">;||      CaspLock + k       |    Down                     ||</span><br><span class="line">;||      CaspLock + j       |    Left                     ||</span><br><span class="line">;||      CaspLock + l       |    Right                    ||</span><br><span class="line">;||      CaspLock + u       |    Home                     ||</span><br><span class="line">;||      CaspLock + m       |    End                      ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line"></span><br><span class="line">CapsLock &amp; k::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Down&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Down&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Down&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Down&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; i::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Up&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Up&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Up&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Up&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">; move left</span><br><span class="line">CapsLock &amp; j::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Left&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;left&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;left&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Left&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; l::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">Send, +&#123;Right&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send,^&#123;Right&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send,^+&#123;Right&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Right&#125;</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; u::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">    Send, +&#123;Home&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;Home&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;Home&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;Home&#125;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; m::</span><br><span class="line">if GetKeyState(&quot;LShift&quot;, &quot;P&quot;)</span><br><span class="line">    Send, +&#123;End&#125;</span><br><span class="line">else if GetKeyState(&quot;LAlt&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;End&#125;</span><br><span class="line">else if GetKeyState(&quot;LControl&quot;, &quot;P&quot;)</span><br><span class="line">Send, ^&#123;End&#125;</span><br><span class="line">else</span><br><span class="line">Send, &#123;End&#125;</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                剪贴板设置成3个                        ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      Ctrl + 1           |    复制到剪贴板1            ||</span><br><span class="line">;||      Ctrl + 2           |    复制到剪贴板2            ||</span><br><span class="line">;||      Ctrl + 3           |    复制到剪贴板3            ||</span><br><span class="line">;||      Alt  + l           |    粘贴剪贴板1的内容        ||</span><br><span class="line">;||      Alt  + 2           |    粘贴剪贴板2的内容        ||</span><br><span class="line">;||      Alt  + 3           |    粘贴剪贴板3的内容        ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">^1:: </span><br><span class="line">Send ^c</span><br><span class="line">a = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^2:: </span><br><span class="line">Send ^c</span><br><span class="line">b = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">^3:: </span><br><span class="line">Send ^c</span><br><span class="line">c = %ClipBoard%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!1:: </span><br><span class="line">ClipBoard = %a%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!2:: </span><br><span class="line">ClipBoard = %b%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">!3:: </span><br><span class="line">ClipBoard = %c%</span><br><span class="line">Send ^v</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                主键盘区域增加小键盘                   ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + p       |    开关                     ||</span><br><span class="line">;||      m                  |    0                        ||</span><br><span class="line">;||      j, k, l            |    1, 2, 3                  ||</span><br><span class="line">;||      u, i, p            |    4, 5, 6                  ||</span><br><span class="line">;||      7, 8, 9            |    7, 8, 9                  ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">#if</span><br><span class="line">CapsLock &amp; p::</span><br><span class="line">ONOFF := !ONOFF</span><br><span class="line">Return</span><br><span class="line">#if ONOFF</span><br><span class="line">&#123;</span><br><span class="line">u::4</span><br><span class="line">i::5</span><br><span class="line">o::6</span><br><span class="line">j::1</span><br><span class="line">k::2</span><br><span class="line">l::3</span><br><span class="line">m::0</span><br><span class="line">n::0</span><br><span class="line">&#125;</span><br><span class="line">#if</span><br><span class="line"></span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                   快捷搜索                            ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + e       |    翻译所选词汇             ||</span><br><span class="line">;||      CapsLock + s       |    搜索所选词汇             ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line"></span><br><span class="line">CapsLock &amp; e::</span><br><span class="line">ffSearchWord = %ClipBoard%</span><br><span class="line">run https://fanyi.baidu.com/#en/zh/%ffSearchWord%</span><br><span class="line">run https://cn.bing.com/dict/search?q=%ffSearchWord%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; s::</span><br><span class="line">Send ^c</span><br><span class="line">content = %ClipBoard%</span><br><span class="line">run https://www.baidu.com/s?wd=%content%</span><br><span class="line">run https://cn.bing.com/search?q=%content%</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">CapsLock &amp; n::</span><br><span class="line">run http://www.baidu.com</span><br><span class="line">return</span><br><span class="line">;************************************************************</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;||                   重新加载本脚本                      ||</span><br><span class="line">;|+-------------------------+-----------------------------+|</span><br><span class="line">;||      CapsLock + r       |    重载                     ||</span><br><span class="line">;|+=======================================================+|</span><br><span class="line">;************************************************************</span><br><span class="line">CapsLock &amp; r::</span><br><span class="line">Send ^s</span><br><span class="line">reload</span><br><span class="line">return</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;键盘和鼠标按键修改工具AutoHotKey可以实现修改任意键盘按键和鼠标按键的功能，可以实现快捷短语的输入。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="AutoHotKey" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/AutoHotKey/"/>
    
    
      <category term="AutoHotKey" scheme="http://FF1204.github.io/hexoblog/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Git 手册</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/Git%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C/"/>
    <id>http://FF1204.github.io/hexoblog/技术/工具/Git/Git查询手册/</id>
    <published>2018-07-29T09:13:42.000Z</published>
    <updated>2019-08-01T02:24:50.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-的结构"><a href="#Git-的结构" class="headerlink" title="Git 的结构"></a>Git 的结构</h2><p>Git 分成三个区域，工作区，暂存区，版本库</p><ul><li><p>工作区：就是和<code>.git</code>文件夹在同一级的工程目录。</p></li><li><p>暂存区：<code>.git</code>中的index中存储暂存区的目录树</p></li><li><p>版本库：<code>.git</code>中的其他地方存储版本库的内容，这个里面包含历史提交和即将要推送到远程版本库的内容。</p></li></ul><p>工作区的文件我们可以从文件管理器直观的看到，暂存区和版本库的文件<code>git</code>只是存储的相应的目录树，具体文件的内容在<code>.git\object</code>对象库中存储，并且使用的是差异化的存储，所以不能之间看到相应的文件，但是可以利用<code>Git</code>提供的工具间接的了解其中的内容。</p><p><img src="git_show_01.svg" alt="Git内部结构"></p><h2 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h2><ul><li><p><code>git diff</code> ： 比较工作区和暂存区的差异</p></li><li><p><code>git diff --cached</code> ： 比较暂存区和版本库的差异</p></li><li><p><code>git diff HEAD</code> : 比较工作区和版本库的差异</p></li></ul><p>将上面命令中的<code>giff</code>换成<code>difftool</code>, 可以使用自定义的图形工具比较差异文件。</p><h2 id="1-从工作区到暂存区"><a href="#1-从工作区到暂存区" class="headerlink" title="1. 从工作区到暂存区"></a>1. 从工作区到暂存区</h2><p>如果想把工作区所做的改动(添加文件、修改内容、删除文件)，可以使用<code>git add</code>命令。</p><ul><li><p><code>git add filename</code> : 把工作区文件filename的改动添加到暂存区</p></li><li><p><code>git reset -- filename</code> : 把添加到暂存区的文件filename 撤销，工作区的文件filename不变，其实就是撤销刚才的<code>git add filename</code> 命令。</p></li><li><p><code>git add .</code> : 把工作区所有改动添加到暂存区</p></li><li><p><code>git reset</code> : 撤销<code>git add .</code>操作</p></li><li><p><code>git add -i</code> : 用交互的方式选择添加哪些文件到暂存区</p></li></ul><h2 id="2-从暂存区到工作区"><a href="#2-从暂存区到工作区" class="headerlink" title="2. 从暂存区到工作区"></a>2. 从暂存区到工作区</h2><ul><li><p><code>git checkout filename</code> : 把暂存区的文件filename添加到工作区，工作区的该文件会被覆盖，其实相当于<code>git add filename</code>的逆操作。</p></li><li><p><code>git reset filename</code> : 用暂存区的文件<code>filename</code>覆盖工作区的文件，相当于<code>git add filename</code>的反操作</p></li><li><p><code>git checkout .</code> : 把暂存区的所有文件添加到工作区，相当于<code>git add .</code>的逆操作。</p></li><li><p><code>git reset</code> : 撤销<code>git add .</code>操作，即用暂存区的内容覆盖工作区的内容。</p></li></ul><p><code>git checkout</code>会清除工作区中尚未<code>add</code>到暂存区中的内容，一定不要用错，否则自己做的工作就要白费了。</p><h2 id="3-从暂存区到版本库"><a href="#3-从暂存区到版本库" class="headerlink" title="3. 从暂存区到版本库"></a>3. 从暂存区到版本库</h2><p>如果想把在暂存区的内容提交到版本库，推送到远程版本库，可以使用<code>git commit</code>命令。</p><ul><li><p><code>git commit</code> : 提交暂存区的内容到版本库，需要写提交说明。</p></li><li><p><code>git commit --allow-empty</code> : 允许提交空的内容</p></li><li><p><code>git commit --amend</code> : 修补提交，不生成新的提交，而是在上一次提交的基础上修改提交内容。</p></li><li><p><code>git reset --soft HEAD^</code> : 撤销最新的提交，相当于<code>git commit</code>的逆操作。 命令解析：<code>--soft</code>选项指定不改变工作区和暂存区, HEAD指向最新的提交，<code>HEAD^</code>指向上一次提交，合起来该命令实现的功能就是撤销最新的提交，而工作区和暂存区的内容不改变。</p></li></ul><h2 id="4-从版本库到暂存区"><a href="#4-从版本库到暂存区" class="headerlink" title="4. 从版本库到暂存区"></a>4. 从版本库到暂存区</h2><ul><li><code>git reset HEAD^</code> : 工作区不改变，暂存区回退到上一次提交，版本库回退到上一次提交。</li></ul><h2 id="5-工作区直接到版本库"><a href="#5-工作区直接到版本库" class="headerlink" title="5. 工作区直接到版本库"></a>5. 工作区直接到版本库</h2><h2 id="6-版本库直接到工作区"><a href="#6-版本库直接到工作区" class="headerlink" title="6. 版本库直接到工作区"></a>6. 版本库直接到工作区</h2><ul><li><code>git reset --hard HEAD^</code> : 工作区、暂存区都会回退到上一次提交，版本库回退到上一次提交</li></ul><h2 id="常用命令解析"><a href="#常用命令解析" class="headerlink" title="常用命令解析"></a>常用命令解析</h2><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a><code>git diff</code></h3><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a><code>git log</code></h3><p><code>git log -g -2 HEAD</code> : 查看最近HEAD指向的两次提交</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a><code>git add</code></h3><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a><code>git checkout</code></h3><p>有两种主要的用法，切换分支 和 检出文件</p><p>检出文件：</p><ul><li><code>git checkout -- filename</code> : 从暂存区检出filename到工作区，工作区未提交的内容会丢失</li><li><code>git checkout -- &#39;.&#39;</code> :用暂存区覆盖工作区</li></ul><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a><code>git reset</code></h3><p>reset就是重置的意思，该命令的本质是修改HEAD指向的提交ID，可以使用不同的参数指定对暂存区和工作区的影响。</p><ul><li><p><code>git reset</code> : 其对应的完成形式应该是<code>git reset --mixed HEAD</code>, 含义是用HEAD指向的内容覆盖暂存区内容，<br>它是<code>git add .</code>的逆操作。</p></li><li><p><code>git reset -- filename</code> : 其完整形式是<code>git reset -- filename HEAD</code>, 含义是用HEAD指向的文件filename的内容覆盖暂存区内容，它是<code>git add filename</code>的逆操作。</p></li><li><p><code>git reset --mixed</code> : 工作区内容不变，暂存区和版本库重置；</p></li><li><p><code>git reset --soft</code> : 工作区和暂存区内容都不变，版本库重置；</p></li><li><p><code>git reset --hard</code> : 工作区，暂存区和版本库都改变。</p></li></ul><p>例如，<code>git reset --soft HEAD^</code>, 撤销最近的提交，暂存区和工作区都不变，要想恢复直接<code>git commit</code>; <code>git reset --mixed HEAD^</code>, 撤销最近的提交和暂存区的内容，要想恢复需要<code>git add .</code>, <code>git commit</code>两条命令； <code>git reset --hard HEAD^</code> 工作区，暂存区都会被上一次提交覆盖，工作区保持和上一次提交一致，未提交的内容会丢失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-的结构&quot;&gt;&lt;a href=&quot;#Git-的结构&quot; class=&quot;headerlink&quot; title=&quot;Git 的结构&quot;&gt;&lt;/a&gt;Git 的结构&lt;/h2&gt;&lt;p&gt;Git 分成三个区域，工作区，暂存区，版本库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;工作区：就是和&lt;cod
      
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Git" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/Git/"/>
    
    
      <category term="Git" scheme="http://FF1204.github.io/hexoblog/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://FF1204.github.io/hexoblog/技术/工具/正则表达式/正则表达式/</id>
    <published>2018-07-29T09:13:42.000Z</published>
    <updated>2019-08-01T02:24:50.498Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是使用一个字符串表达一个要匹配的模式。模式的表示通过元字符，正则表达式常用的元字符及含义如下：</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th>匹配单个字符</th><th>含义</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配任意一个字符，除了<code>\r</code>和<code>\n</code></td></tr><tr><td><code>\d</code></td><td>匹配数字0-9，等价于<code>[0-9]</code></td></tr><tr><td><code>\D</code></td><td>匹配除了0-9之外的字符,等价于<code>[^0-9]</code></td></tr><tr><td><code>\w</code></td><td>匹配任何一个字母数字或者下划线，等价于<code>[A-Za-z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配任何一个非字母数字下划线，等价于<code>[^A-Za-z0-9_]</code></td></tr><tr><td><code>\b</code></td><td>匹配单词边界</td></tr><tr><td><code>\B</code></td><td>匹配非单词边界</td></tr><tr><td><code>\s</code></td><td>匹配任意一个空白字符，等价于<code>[\f\n\r\t\v]</code></td></tr><tr><td><code>\S</code></td><td>匹配任意一个非空白字符</td></tr><tr><td><code>^</code></td><td>匹配一行的开头</td></tr><tr><td><code>$</code></td><td>匹配一行的结束</td></tr></tbody></table><table><thead><tr><th>匹配重复次数</th><th>含义</th></tr></thead><tbody><tr><td><code>?</code></td><td>匹配0次或者1次，用在一个表达式后面可以表示非贪心的匹配</td></tr><tr><td><code>+</code></td><td>匹配一次或者多次</td></tr><tr><td><code>*</code></td><td>匹配0次或者多次</td></tr><tr><td><code>{n}</code></td><td>匹配n次</td></tr><tr><td><code>{m,}</code></td><td>至少匹配m次</td></tr><tr><td><code>{m,n}</code></td><td>最少匹配m次，最多匹配n次</td></tr></tbody></table><p>了解了以上的元字符，便可以构造匹配任意字符任意次的一个模式，但是还不能指定多个字符构成的模式的重复次数，下面介绍分组和捕获的相关内容。</p><table><thead><tr><th>逻辑控制</th><th>含义</th></tr></thead><tbody><tr><td>`x</td><td>y`</td><td>逻辑或，匹配x或者匹配y</td></tr><tr><td><code>{}</code></td><td>里面跟数字，指定前面的模式的重复次数</td></tr><tr><td><code>[]</code></td><td>里面放置任意字符，都是或的关系，匹配这个集合里面的任意一个</td></tr><tr><td><code>(pattern)</code></td><td>指定分组，分组后面紧跟的描述符描述的是这一组模式重复的次数,这个分组会被捕获，可以使用<code>\num</code>来引用捕获的这个分组</td></tr><tr><td><code>(?:pattern)</code></td><td>指定这个分组不被捕获</td></tr><tr><td><code>(?=pattern)</code></td><td>非捕获匹配，正向肯定预先查找，匹配后面符合pattern的前面部分，例如`Windows(?=95</td><td>98</td><td>NT</td><td>2000)<code>,在匹配</code>Windows的时候会查找<code>Windows后面的字符，只匹配那些后面紧跟的是</code>95<code>,</code>98<code>,</code>NT<code>,</code>2000<code>的</code>Windows<code>,而不会匹配到</code>Windows3.1<code>中的</code>Windows`</td></tr><tr><td><code>(?!pattern)</code></td><td>非捕获匹配，正向非肯定预先查找</td></tr><tr><td><code>(?&lt;=pattern)</code></td><td>非捕获匹配，反向肯定预先查找</td></tr><tr><td><code>(?&lt;!pattern)</code></td><td>非捕获查找，反向非肯定预先查找</td></tr></tbody></table><h2 id="常用实例解析"><a href="#常用实例解析" class="headerlink" title="常用实例解析"></a>常用实例解析</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式是使用一个字符串表达一个要匹配的模式。模式的表示通过元字符，正则表达式常用的元字符及含义如下：&lt;/p&gt;
&lt;h2 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h2&gt;&lt;table&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="正则表达式" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第七章-感知机</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第七章-感知机/</id>
    <published>2017-11-04T01:06:41.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第六章-kmeans</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%85%AD%E7%AB%A0-kmeans/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第六章-kmeans/</id>
    <published>2017-11-04T01:06:21.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第五章-最近邻</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%80%E8%BF%91%E9%82%BB/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第五章-最近邻/</id>
    <published>2017-11-04T01:05:45.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习-第四章-支持向量机</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第四章-支持向量机/</id>
    <published>2017-11-04T01:05:10.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <content type="html"><![CDATA[<p>【支持向量机】【函数间隔】【几何间隔】【KTT】</p><a id="more"></a><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>令 $\theta = (w_1,w_2,…,w_n,b)$, $x = (x_1,x_2,…,x_n,1)$,则有：<br>$$<br>\theta^T \cdot x = w_1x_1+x_2x_2+…+w_nx_n+b<br>$$</p><p>支持向量机要得到的分类决策函数是：</p><p>$$<br>h_\theta(x) = sign(\theta^T \cdot x)<br>$$</p><p>其中，$sign(x)$的定义是：</p><p>$$<br>sign(x) = \begin{cases}<br>          1, &amp; x&gt;=0 \<br>          0, &amp; x &lt; 0 \<br>          \end{cases}<br>$$</p><p>当$\theta^T &gt;= 0$ 的时候，分类成正类，当$\theta^T &lt; 0$的时候，分类成负类。支持向量机就是通过给定的训练数据求解出$\theta$.</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="函数间隔"><a href="#函数间隔" class="headerlink" title="函数间隔"></a>函数间隔</h3><p>$\theta^T \cdot x = 0$ 可以确定一个超平面(n维空间中，n-1维的叫做超平面)，$\theta^T \cdot x &gt; 0$ 的时候，我们定义类别的标签是<code>1</code>, $\theta^T \cdot x &lt; 0$ 的时候，我们定义类别的标签是<code>-1</code>. 这样，$\theta^T \cdot x$的符号和标签<code>y</code>的符号是一致的。 $ y(\theta^T \cdot x ) &gt; 0 $ 表示分类正确， $y(\theta^T \cdot x)&lt;0 $ 表示分类错误. 而$|\theta^T \cdot x|$表示的是点<code>x</code>到分类超平面的距离，可以认为距离越远，分类的可信度越高。</p><p>点$(x_i,y_i)$函数间隔的定义为：</p><p>$$<br>\hat \gamma_i = y_i(\theta^T \cdot x_i)<br>$$</p><p>训练集合中所有样本的函数间隔定义为所有样本的函数间隔最小的那一个。</p><h3 id="几何间隔"><a href="#几何间隔" class="headerlink" title="几何间隔"></a>几何间隔</h3><p>$\theta^T \cdot x = wx+b$, 其中$w = (w_1,w_2,…,w_n)$. 函数间隔有一个问题，就是成比例的改变$w$和$b$的值，函数间隔的大小就会成比例的变化。所以函数间隔并不适合用来求极值点。 改进的方法是限制$w$的取值，是$||w|| = 1$, 这样函数间隔就变成了几何间隔。</p><p>样本$(x_i,y_i)$到分类超平面$wx+b=0$的几何间隔是：</p><p>$$<br>\gamma_i = y_i(\frac w {||w||} \cdot x_i + \frac b {||w||})<br>$$</p><p>训练集的几何间隔取 训练集合中所有的样本点到分类超平面几何间隔的最小值。</p><p><strong>优化目标</strong></p><p>支持向量机的优化目标就是找到使得 几何间隔最大化的参数取值。这是一个约束优化问题，目标是$max(\gamma)$, 约束条件是$\gamma_i &gt;= \gamma$, 含义是在保证某个点的几何间隔都大于等于$\gamma$的情况下，求最大的$\gamma$. </p><p>在约束条件两边都乘以一个$||w||$, 等式的性质不变，现在约束变成 $y_i(w \cdot x_i + b) &gt;= \hat \gamma$, 因为 $\gamma = \frac {\hat \gamma} \gamma$, 最优化的目标变为： $\frac {\hat \gamma} {||w||}$, $\hat \gamma$的取值是不影响最后的结果的，前面介绍过了，函数间隔会根据$w$和$b$的取值等比例的缩放，所以这里我们令$\hat \gamma = 1$, 最优化问题可以写成下面的形式：</p><p>$$<br>min \quad \frac 1 2 {||w||^2} \<br>s.t. \quad y_i(w \cdot x_i + b)-1 &gt;= 0, \quad \text{i=1,2,…,n}<br>$$</p><blockquote><p>最大化 $\frac 1 {||w||}$ 等价于 最小化$\frac 1 2 {||w||^2}$</p></blockquote><p>支持向量机就是求解上面的最优化问题，来求得参数$\theta$，然后构造分类超平面为未知的数据分类的。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="拉格朗日函数"><a href="#拉格朗日函数" class="headerlink" title="拉格朗日函数"></a>拉格朗日函数</h3><p>凸优化问题的一般形式</p><p>$$<br>min \quad f(x) \<br>s.t. \quad c_i(x) &lt;= 0, \quad i = 1,2,…,k \<br>           h_j(x) = 0, \quad j = 1,2,…,l<br>$$</p><p>其中，$f(x)$和$c_i(x)$ 都是 $R^n$上的连续可微的凸函数，$h_j(x)$ 是 $R^n$上的仿射函数。</p><blockquote><p>$f(x)$是仿射函数的含义是满足条件：$f(x) = ax+b$,其中$a \in R^n$,$b \in R$,$x \in R^n$.</p></blockquote><p>拉格朗日函数是在 约束优化问题中 用来把约束条件添加到目标函数中的一种手段，广义的拉格朗日函数的定义是：</p><p>$$<br>L(x,\alpha,\beta) = f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x) \quad \alpha_i &gt;= 0<br>$$</p><p>其中，$f(x)$是原来约束优化问题的目标函数，$c_i(x)$和$h_j(x)$是约束条件中的函数.</p><p>定义函数：</p><p>$$<br>P(x) = \mathop{max} \limits_{\alpha,\beta} L(x,\alpha,\beta)<br>$$</p><p>其中，$P(x)$表示在把$x$看作常数，$\alpha,\beta$看作变量的情况下，求$L(x,\alpha,\beta)$的最大值；</p><p>现在来分析函数$P(x)$, 如果$x$满足原来最优化问题的约束条件，即$c_i(x) &lt;= 0$, $h_j(x) = 0$, 那么 $P(x) = \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x))$, 这个时候的最大值的结果就是$P(x) = f(x)$, $\alpha_i = 0$. 除此之外，$\alpha_i$取任何大于0的值最后的结果都会减小。</p><p>如果$x$不满足约束条件，即 $c_i(x) &gt; 0$ 或者 $h_j(x) \neq 0$, 这个时候总能找到满足的 $\alpha$ 或 $\beta$ ,使得 $P(x) = +\infty$ . 例如，如果$c_i(x) &gt; 0$, 只需要让$\alpha_i$足够大，就能保证结果足够大，如果$h_j(x) \neq 0$, 只需要让$\beta_j$足够大就能保证结果趋近 $+\infty$ .</p><p>综上，$P(x)$是一个满足下述条件的函数：</p><p>$$<br>P(x) = \begin{cases}<br>        f(x) &amp; \text{x 满足约束条件} \<br>        +\infty &amp; \text{x 不满足约束条件}<br>       \end{cases}<br>$$</p><p>那么， $min P(x)$ 表示求$P(x)$的最小值，其含义就是求在满足约束条件的情况下，$f(x)$的最小值。所以原来的约束最优化问题，在引入拉格朗日函数之后，可以变成下面的无约束优化问题，它与原来的问题等价：</p><p>$$<br>\mathop{min} \limits_x   \quad \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0<br>$$</p><h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><p>如果原始问题是：</p><p>$$<br>p^*  =  \mathop{min} \limits_x   \quad \mathop{max} \limits_{\alpha,\beta} ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0<br>$$</p><p>则它的对偶问题是：</p><p>$$<br>d^* =   \mathop{max} \limits_{\alpha,\beta}  \quad  \mathop{min} \limits_x   ( f(x) + \sum_{i=1}^k \alpha_i c_i(x) + \sum_{j=1}^l \beta_j h_j(x))  \quad \alpha_i &gt;= 0<br>$$</p><p>原问题是先固定的把$x$看作常数，求解$\alpha,\beta$, 再把$\alpha,\beta$看作常数，求解$x$;<br>而对偶问题正好反了过来，是先把$\alpha,\beta$看作常数，求解出$x$,再把$x$看作常数，求解出$\alpha,\beta$</p><p>如果$p^<em>$表示原始问题的最优解，而$d^</em>$表示对偶问题的最优解，则有$d^<em> &lt;= p^</em>$. 原问题的解是大于等于对偶问题的最优解的，如果想通过解对偶问题来解原来的问题，需要满足如下的KKT条件，才能保证原问题和对偶问题的解相同：</p><p>$$<br>\triangledown_x L(x,\alpha,\beta) = 0 \<br>\triangledown_{\alpha} L(x,\alpha,\beta) = 0 \<br>\triangledown_{\beta} L(x,\alpha,\beta) = 0 \<br>\alpha_ic_i(x) = 0,i=1,2,…,k \<br>c_i(x) &lt;=0, i = 1,2,…,k \<br>\alpha_i &gt;= 0, i=1,2,…,k \<br>h_j(x) = 0, j=1,2,…,l<br>$$</p><p>其中， $x,\alpha,\beta$,分别代表原始问题和最优问题的解。如果满足上述的约束条件，则原始问题和对偶问题有相同的解。 前三个条件是对$x,\alpha,\beta$的偏导数为0， 后三个条件是原来问题的约束条件，只有中间的条件是新的约束条件 $\alpha_i c_i(x) = 0$, 这意味着如果$\alpha_i &gt; 0$, 那么$c_i(x) = 0$，否则约束条件就无法得到满足。</p><h3 id="求解原问题"><a href="#求解原问题" class="headerlink" title="求解原问题"></a>求解原问题</h3><p>支持向量机的优化目标是：</p><p>$$<br>min \quad \frac 1 2 {||w||^2} \<br>s.t. \quad y_i(w \cdot x_i + b)-1 &gt;= 0, \quad \text{i=1,2,…,n}<br>$$</p><p>把约束条件加入优化函数，改写成拉格朗日函数如下：</p><p>$$<br>L(w,\alpha) = \frac 1 2 {||w||^2} - ( \sum_{k=1}^m \alpha_i (y_i(w \cdot x_i + b)-1) )<br>$$</p><p>因为没有等式约束条件，所以这里没有$\beta$, 还有这里是$-$号，因为凸优化的标准约束是小于等于的形式，而这里却是大于等于的形式。</p><p>所以原来的优化问题可以转化成求解下面的问题：</p><p>$$<br>\mathop{min} \limits_w \quad \mathop{max} \limits_{\alpha} L(w,\alpha)<br>$$</p><p>它的对偶问题是:</p><p>$$<br>\mathop{max} \limits_{\alpha} \quad \mathop{min} \limits_w  L(w,\alpha)<br>$$</p><p>首先要求解$\mathop{min} \limits_w  L(w,\alpha)$, 这个时候$w,b$是变量，$\alpha$看作常量，求解函数 $\frac 1 2 {||w||^2} - ( \sum_{k=1}^m \alpha_i (y_i(w \cdot x_i + b)-1) )$ 的最小值。</p><blockquote><p>多元函数的极值点必在驻点（偏导数为0的点）和偏导数不存在的点中。</p></blockquote><p>要求极值点，首先对每个变量($w,b$)求偏导数，令其等于0：</p><p>$$<br>\triangledown_w L(w,b,\alpha) = w - \sum_{i=1}^m \alpha_i y_i x_i = 0 \<br>\triangledown_b L(w,b,\alpha) = \sum_{i=1}^m \alpha_i y_i = 0<br>$$</p><p>把得到的等式带入原来的式子$L(w,b,\alpha)$中化简,去掉$w,b$,得到只有$x,y,\alpha$的表达式：</p><p>$$<br>\mathop{min} \limits_{w,b}  L(w,b,\alpha)  = - \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) + \sum_{i=1}^m \alpha_i<br>$$</p><p>上式中，$w,b$已经确定了，得到了一个极小值，下一步是求极大值$\mathop{max} \limits_{\alpha} \quad \mathop{min} \limits_{w,b}  L(w,b,\alpha)$, 具体的式子带入，转化成求如下的约束优化问题：</p><p>$$<br>\mathop{max} \limits_{\alpha}  \quad - \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) + \sum_{i=1}^m \alpha_i \<br>s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \<br>    \alpha_i &gt;= 0, \quad i=1,2,…,m<br>$$</p><p>把求解最大化问题转化成求解最小化问题：</p><p>$$<br>\mathop{min} \limits_{\alpha}  \quad  \frac 1 2 \sum_{i=1}^m \sum_{j=1}^m \alpha_i \alpha_j y_i y_j(x_i \cdot  x_j) - \sum_{i=1}^m \alpha_i \<br>s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \<br>    \alpha_i &gt;= 0, \quad i=1,2,…,m<br>$$</p><p>设该问题的解是$\alpha^<em>$, 则原来问题的解是$w^</em>,b^*$, KKT条件成立，可以导出三者之间的关系为：</p><p>$$<br>w^<em> = \sum_{i=1}^m \alpha^</em> y_i x_i \<br>b^<em> = y_i - \sum_{i=1}^m \alpha^</em> y_i (x_i \cdot x_j)<br>$$</p><h3 id="求解支持向量机参数的一般步骤"><a href="#求解支持向量机参数的一般步骤" class="headerlink" title="求解支持向量机参数的一般步骤"></a>求解支持向量机参数的一般步骤</h3><p>输入：训练集$(x_i,y_i)$, 训练集合有样本<code>m</code>个，特征数量<code>n</code>个。</p><p>输出：分类决策函数</p><p><strong>最大间隔法</strong></p><ol><li>构造并求解约束最优化问题：</li></ol><p>$$<br>\mathop{min} \limits_{w,b} \quad \frac 1 2 {||w||^2} \<br>s.t. \quad  y_i(w \cdot x_i + b) - 1 &gt;= 0, \quad i=1,2,…,m<br>$$</p><ol start="2"><li><p>求解该问题得到问题的解$w^<em>,b^</em>$</p></li><li><p>构造分类平面 $w^<em> \cdot x + b^</em> = 0$</p></li></ol><p><strong>对偶学习算法</strong></p><ol><li>构造并求解约束最优化问题：</li></ol><p>$$<br>\mathop{min} \limits_{\alpha} \quad \frac 1 2 \sum_{i=1}^n \sum_{j=1}^n \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i=1}^n \<br>s.t. \quad \sum_{i=1}^m \alpha_i y_i = 0 \<br>    \alpha_i &gt;= 0, \quad i=1,2,…,m<br>$$</p><p>求解上面的最优化问题得到 $\alpha^*$.</p><ol start="2"><li>计算 $w^<em>$ 和 $b^</em>$ :</li></ol><p>$$<br>w^<em> = \sum_{i=1}^n \alpha^</em> y_i x_i \<br>b^<em> = y_i - \sum_{i=1}^n \alpha^</em>_i y_i (x_i \cdot x_j)<br>$$</p><ol start="3"><li>根据第二步求解的参数构造分类决策函数：</li></ol><p>$$<br>w^<em> \cdot x + b^</em> = 0<br>$$</p><h3 id="一个具体的例子"><a href="#一个具体的例子" class="headerlink" title="一个具体的例子"></a>一个具体的例子</h3><p>有三个训练样本，每个样本有两个特征，$x_1 = (3,3), x_2 = (4,3), x_3 = (1,1)$, 求支持向量机的分类超平面。其中$x_1,x_2$是正样本，$x_3$是负样本。</p><ol><li>用最大间隔法求解</li></ol><p>根据数据构造约束最优化问题：</p><p>$$<br>\mathop{min} \limits_{w,b} \quad \frac 1 2 (w_1^2+w_2^2) \<br>s.t. \quad 3w_1 + 3w_2 + b &gt;= 1 \<br>           4w_1 + 4w_2 + b &gt;= 1 \<br>           -w_1 - w_2 - b &gt;= 1<br>$$</p><p>求解此最优化问题得到结果：$w_1 = w_2 = \frac 1 2, b = -2$, 最后的分类超平面是:</p><p>$$<br>\frac 1 2 x^{(1)} + \frac 1 2 x^{(2)} - 2 = 0<br>$$</p><ol start="2"><li>用对偶学习算法求解：</li></ol><p>根据数据构造约束最优化问题：</p><p>$$<br>\mathop{min} \limits_{\alpha} \quad \frac 1 2 (18\alpha_1^2 + 25\alpha_2^2 + 2\alpha_3^2 + 42 \alpha_1 \alpha_2 - 12 \alpha_1 \alpha_3 - 14 \alpha_2 \alpha_3) - (\alpha_1 + \alpha_2 + \alpha_3)  \<br>s.t. \quad \alpha_1 + \alpha_2 - \alpha_3 = 0 \<br>           \alpha_i &gt;= 0, \quad i=1,2,3<br>$$</p><p>求解最优化问题得到结果：$\alpha_1 = \frac 1 4, \alpha_2 = 0, \alpha_3 = \frac 1 4$.</p><p>则可以得到 $w_1^<em> = = w_2^</em> = \frac 1 2$, $b^* = -2$.</p><p>最后的分类超平面为：</p><p>$$<br>\frac 1 2 x^{(1)} + \frac 1 2 x^{(2)} - 2 = 0<br>$$</p><p>比较最大间隔算法和对偶学习算法可以看出，对偶学习算法更容易求解，因为其约束条件变得更少，更容易得到不同变量之间的转换关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【支持向量机】【函数间隔】【几何间隔】【KTT】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://FF1204.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-第三章-朴素贝叶斯</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第三章-朴素贝叶斯/</id>
    <published>2017-11-04T01:04:49.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://FF1204.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-第二章-决策树</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第二章-决策树/</id>
    <published>2017-11-04T01:04:25.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <content type="html"><![CDATA[<p>【决策树】【ID3】【C4.5】</p><a id="more"></a><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>一棵树，每次分支都按照某个属性确定分到哪一个分支，直到所有的数据集都被分到正确的类别上。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>主要涉及使用什么指标划分</p><p>如何剪枝避免过拟合</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>ID3</p><p>C4.5</p><p>CART</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【决策树】【ID3】【C4.5】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://FF1204.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-第一章-逻辑回归</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-第一章-逻辑回归/</id>
    <published>2017-11-04T01:04:05.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <content type="html"><![CDATA[<p>【逻辑回归】</p><a id="more"></a><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>令 $\theta = (w_1,w_2,…,w_n,b)$, $x = (x_1,x_2,…,x_n,1)$,则有：<br>$$<br>\theta^T \cdot x = w_1x_1+x_2x_2+…+w_nx_n+b<br>$$</p><p>逻辑回归要训练得到的函数模型是：</p><p>$$<br>h_\theta(x) = f(\theta^T \cdot x)<br>$$</p><p>其中<code>f</code>是下面的函数：</p><p>$$<br>f(z) = \frac 1 {1+e^{-z}}<br>$$</p><p>函数<code>f</code>的图像如下图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plot[<span class="number">1.0</span> / (<span class="number">1</span> + E^(-x)), &#123;x, <span class="number">-10</span>, <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure><p><img src="softmax.png" alt="f(z)"></p><p>$h_\theta(x)$ 的结果是<code>(0,1)</code>，含义是类别为正类别的概率; $\theta$的含义是模型的参数.</p><p>算法的目标是在已知$(x_1,x_2,…x_n)$ 和对应的 $y$ 的若干个样本的情况下，求解出$(w_1,w_2,…,w_n,b)$这些参数，使得损失函数最小。</p><blockquote><p>Wolfram Mathematica 是一个专业的科学计算软件，使用它可以非常方便的绘制出函数的图形。<code>Plot[1.0 / (1 + E^(-x)), {x, -10, 10}]</code>就是绘制出上面的函数图形的命令。</p></blockquote><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>逻辑回归使用的损失函数是：</p><p>$$<br>cost(h_\theta(x),y) = \begin{cases}<br>                      -log(h_\theta(x)) &amp; \text{if y = 1} \<br>                      -log(1-h_\theta(x)) &amp;  \text{if y = 0}<br>                      \end{cases}<br>$$</p><p>其中，$h_\theta(x)$就是模型预测的结果，$y$是实际的标签，取值是$0，1$.</p><p>当$y=1$时，$h_\theta(x)$接近1的时候，损失函数$-log(h_\theta(x))$接近0，而当$h_\theta(x)$接近0的时候，损失函数是接近正无穷的。其对应的关系如下图所示：</p><p><img src="hox.png" alt></p><p>当$y = 0$时，$h_\theta(x)$接近0的时候，损失函数$-log(1-h_\theta(x))$接近0，而当$h_\theta(x)$接近1的时候，损失函数$-log(1-h_\theta(x))$接近正无穷。其对应的关系如下图所示：</p><p><img src="hox2.png" alt></p><p>分段函数不利于表达，把上面的<code>cost</code>函数写成统一的格式如下：</p><p>$$<br>cost(h_\theta(x),y) = - ( y \times log(h_\theta(x))  +  (1-y) \times log(1-h_\theta(x)) )<br>$$</p><p>对于一个有<code>m</code>个样本的训练集，训练集上的损失为：</p><p>$$<br>J(\theta) = - \frac 1 m \sum_{i=1}^{m} (y^{(i)} \times log(h_\theta(x^{(i)})) + (1-y^{(i)}) \times log(1-h_\theta(x^{(i)})))<br>$$</p><p>其中，$i$表示训练集中的第$i$个样本，$x$表示特征向量$(x_1,x_2,…,x_n,x_{n+1})$, $y$ 表示实际的标签，取值$0,1$。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>找到一种算法，在已经知道$x$和$y$的情况下，求解出能够使得$J(\theta)$最小的$\theta$的值，具体的就是$(w_1,w_2,…,w_n,b)$的值。</p><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p><strong>梯度</strong>， 函数对每一个参数求偏导数，偏导数组合成向量，向量的方向就是梯度的方向，函数在梯度的方向上升最快，在梯度的反方向下降最快。</p><p>使用梯度下降法求解参数的步骤：</p><ol><li>初始化参数。</li></ol><p>首先给参数一个初始值$\theta = \theta^0$, 定义一个步长$\alpha$,就是每次要在梯度的方向上移动的距离; 定义一个终止条件$\epsilon$，确定算法在什么条件下终止。（一般是看参数更新前后两者的差值，小于某一个很小的数字，就可以结束算法）</p><ol start="2"><li>计算梯度： </li></ol><p>$$<br>\frac \partial {\partial\theta_j} J(\theta_1,\theta_2,…,\theta_{n+1})) = \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x<br>$$</p><p>其中，$j \in (1,n+1)$ 表示第<code>j</code>个参数， $i \in (1,m)$ 表示第<code>m</code>个样本。</p><blockquote><p>这里涉及到函数的求导，先来复习一下函数的链式求导法则：<br>$$<br>\frac {dx} {dy} = \frac {dx} {dz} \times \frac {dz} {dy}<br>$$<br>举个例子：<br>sigmoid 函数的导数是：<br>$$<br>y = f(z) = \frac 1 {1 + e^{-z}}<br>$$<br>它的导数可以很容易的求出来，还可以把它表示成y的乘积的形式。<br>$$<br>\frac {dy} {dz} = \frac {e^{-z}} {1+e^{-z}} = y(1-y)<br>$$ </p></blockquote><p>现在来求损失函数的对每一个参数$\theta_i$的导数：</p><p>$$<br>\frac {\partial cos(h_\theta,y)} {\partial \theta} = (h_\theta(x) - y) \cdot x<br>$$</p><p>假设一共有<code>m</code>个训练样本,$i \in (1,m)$, 一共有<code>n+1</code>个参数，$j \in (1,n+1)$, 则每个参数的导数如下：</p><p>$$<br>\frac {\partial cos(h_\theta(x),y)}  {\theta_j}   =  \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}))  x_j^{(i)}<br>$$</p><p>根据上面的公式，初始化$\theta^0$之后，可以利用整个训练集的数据$(x^{(i)},y^{(i)}),i \in (1,m)$, 计算出一个梯度向量$(\Delta \theta_1,\Delta \theta_2,…,\Delta \theta_{n+1})$.</p><ol start="3"><li>更新参数</li></ol><p>$$<br>\theta^{i+1} = \theta^i + \alpha \Delta \theta^i<br>$$</p><p>其中，$\theta^i$表示第$i$次迭代的时候的参数取值，$\Delta \theta^i$表示第二步计算出来的梯度，$\alpha$表示 <strong>学习率</strong>，是控制梯度下降的每步大小的一个超参数，需要自己设置。</p><ol start="4"><li>比较更新前后的参数的变化</li></ol><p>$$<br>\epsilon = \sum_{i=1}^{n+1} ( \theta^{i+1} - \theta^{i} )<br>$$</p><p>如果$\epsilon$的值小于预先确定的结束条件，算法结束，最后的$\theta$就是要求解的参数，如果$\epsilon$大于结束条件，则转到第三步继续迭代，直到满足结束条件为止。</p><blockquote><p>梯度下降的几种策略：<br>上面的例子中，每一次参数的更新，我们是使用训练集中的所有样本计算的梯度，这样做每次计算出来的梯度比较准确，但是当训练集合非常大的时候，每次的计算开销就很大。<br>$$<br>\frac {\partial cos(h_\theta(x),y)}  {\theta_j}   =  \frac 1 m   \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}))  x_j^{(i)}<br>$$<br>可以看出，求解的方法是每个样本计算出一个梯度，然后求和取平均值作为最后的梯度。</p><p><strong>随机梯度下降法</strong></p><p>随机梯度下降法就是把上面的式子中的求和符号去掉，每次只使用一个样本计算梯度，计算出来就更新一次参数，然后再在更新之后的参数上，利用下一个样本计算梯度，这样每次更新的速度都很快，但是只是利用一个样本计算出来的梯度可能根本就不是函数上升最快的方向，所以收敛的速度不一定快。</p><p><strong>批量梯度下降法</strong></p><p>这种方法就综合上面两种方法的利弊提出的，每次使用若干个（一般是10个）样本计算梯度，计算完就更新参数，然后在更新的参数的基础上利用另外的10个样本计算下一个梯度方向，直到算法结束。</p></blockquote><h3 id="梯度下降法算法调优"><a href="#梯度下降法算法调优" class="headerlink" title="梯度下降法算法调优"></a>梯度下降法算法调优</h3><p>通过梯度下降法的求解过程，我们知道要设置三个重要的参数，一个是$\theta^0$, 初始参数的值；一个是$\alpha$,学习率；一个是算法停止条件，$\epsilon$.</p><p>如果要优化的函数是凸函数（只有一个极值点），$\theta^0$ 的值不会影响最终的结果，但是会影响算法结束的速度；如果优化的函数有多个极值点，$\theta^0$ 的初始值会影响最后的结果。这个时候，一个解决的办法是随机选择多次初始点，分别计算出极值点，选择极值点最小的那个初始点作为算法的初始点。 理论上如果选择足够多的初始点(并且是随机选择)，一定可以找到真正的极值点。</p><p>$\alpha$ 的选择也十分重要，如果过小，算法迭代次数过多，会结束的非常慢；如果过大，很可能会越过极值点，找不到正确的结果。</p><p>$\epsilon$ 的选择影响算法的终止条件，如果过大，可能还没有达到极值点就结束了，如果过小，可能导致算法运行时间过长。</p><p>除此之外，使用梯度下降法时候，特征一般要归一化处理，这是因为，如果不同的维度取值范围差异很大的话，算法的迭代效率就很差，归一化的方法是计算数据的均值和方差，然后每个特征减去均值之后除以标准差</p><p>使用随机梯度下降的时候，如果数据集不是线性可分的(存在噪声的情况)，可能会造成梯度来回波动的情况，可以下面的方式优化：</p><blockquote><ul><li>在每次迭代时，调整更新步长$\alpha$的值。随着迭代的进行，$\alpha$越来越小，这会缓解系数的高频波动（也就是每次迭代系数改变得太大，跳的跨度太大）。当然了，为了避免$\alpha$随着迭代不断减小到接近于0（这时候，系数几乎没有调整，那么迭代也没有意义了），我们约束$\alpha$一定大于一个稍微大点的常数项.</li></ul></blockquote><blockquote><ul><li>每次迭代，改变样本的优化顺序。也就是随机选择样本来更新回归系数。这样做可以减少周期性的波动，因为样本顺序的改变，使得每次迭代不再形成周期性。</li></ul></blockquote><h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><h3 id="拟牛顿法"><a href="#拟牛顿法" class="headerlink" title="拟牛顿法"></a>拟牛顿法</h3><h2 id="对模型的理解"><a href="#对模型的理解" class="headerlink" title="对模型的理解"></a>对模型的理解</h2><p>理解一个模型的含义有时候会很有帮助，但不是所有的模型都有确切的含义，幸运的是，逻辑回归模型有一些很好的解释便于理解实际含义。</p><p><strong>对数几率</strong></p><p>在逻辑回归模型中，$\theta^T \cdot x$的值是有含义的。假设一件事发生的概率是$P$,不发生的概率是$1-P$,定义一件事发生的<strong>几率</strong> 为发生的概率和不发生的概率的比值：$p / (1-p)$. 定义一件事发生的对数几率是：$log(p / (1-p))$.</p><p>逻辑回归的输出$h_\theta(x)$可以看作分类为1的概率：</p><p>$$<br>P(Y=1|X) = h_\theta(x) = \frac 1 {1 + e^{-\theta^T \cdot x}}<br>$$</p><p>记A表示分类结果是1这一时间，则A的对数几率是：</p><p>$$<br>logit(A) = log(\frac {h_\theta(x)} {1-h_\theta(x)}) = \theta^T = w_1 x_1+ x_2 x_2 + … + w_n x_n + b<br>$$</p><p>$\theta^T \cdot x$ 的含义其实是事件A发生的对数几率，取对数并不影响函数原来的极值点，可以认为是原来的含义。所以可以认为$\theta^T \cdot x$ 度量了事件A发生的几率。<br>而原来的$h_\theta(x)$ 表示的事件A发生的概率。</p><p><strong>最大似然</strong></p><p>最大似然的思想是： 选择使得已经发生的事件概率取得最大值的 那些参数。 例如$\theta$表示箱子的编号，1号箱子里面有1个红球，9个白球，2号箱子里面有1个白球，9个红球；如果任意选择一个箱子，任意取一个球，发现取得的是红球，那么根据最大似然的原理$\theta = 2$,因为如果是2号箱子，取得红球的概率是0.9， 如果是1号箱子，取得红球的概率是0.1.</p><p>把训练集中的出现的样本作为一次实验，那么出现这种实验结果的概率是：</p><p>$$<br>P(Y=1|X)^{y_i} (1-P(Y=0|X))^{1-y_i}<br>$$</p><p>所有的<code>m</code>个样本出现的概率是每一个样本出现的概率的乘积：</p><p>$$<br>L(\theta) = \prod_{i=1}^m (h_\theta(x))^{y_i} (1-h_\theta(x))^{1-y_i}<br>$$</p><p>用最大似然的观点，逻辑回归转化成求$L(\theta)$最大的时候，$\theta$的值。求解该函数的极大值，就是求解负函数的极小值。对$\theta$求导之后会发现，最优化函数和上面提到的用损失函数表示的是一样的。所以求解的方法依然是梯度下降法。</p><h2 id="编写算法（Python）"><a href="#编写算法（Python）" class="headerlink" title="编写算法（Python）"></a>编写算法（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sat Nov 04 20:47:47 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: FF120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math <span class="keyword">as</span> mm</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    theta : 初始的参数选择(n+1_features),最后一个参数是截距b</span></span><br><span class="line"><span class="string">    alpha : 学习率</span></span><br><span class="line"><span class="string">    epsilon : 终止条件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,theta,alpha,epsilon)</span>:</span></span><br><span class="line">        self.theta = theta</span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + mm.exp(-z))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_theta</span><span class="params">(self,X,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用所有训练数据完成一次参数的更新过程</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回值</span></span><br><span class="line"><span class="string">        epsilon: 本次更新的梯度和上次的差异</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = X.shape</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>): <span class="comment"># 第j个参数的偏移</span></span><br><span class="line">            delta_theta = np.zeros((<span class="number">1</span>,n+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> i,line_x,line_y <span class="keyword">in</span> enumerate(zip(X,y)):</span><br><span class="line">                line_x = np.array(list(line_x) + [<span class="number">1</span>]) <span class="comment"># 添加x_n+1</span></span><br><span class="line">                theta = np.array(self.theta)</span><br><span class="line">                delta_theta[i] += self.sigmoid(np.dot(theta.T,line_x) - line_y) * (line_x[j])</span><br><span class="line">                </span><br><span class="line">            delta_theta = delta_theta*(<span class="number">1.0</span> / m)</span><br><span class="line">            epsilon = np.sum(np.absolute(self.alpha *delta_theta))</span><br><span class="line">            self.theta = self.theta + self.alpha * delta_theta</span><br><span class="line">            <span class="keyword">return</span> epsilon</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fix</span><span class="params">(self,X,y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        X : (n_samples,n_featues) 训练集合</span></span><br><span class="line"><span class="string">        y : (n_samples,) 训练集对应的标签</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            epsilon = self.update_theta(X,y)</span><br><span class="line">            <span class="keyword">if</span> epsilon &lt; self.epsilon:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        X : (n_samples.n_features) 训练集合</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> X.shape[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            y = self.sigmoid( np.dot(self.theta.T,X) )</span><br><span class="line">            <span class="keyword">if</span> y &gt;= <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> y &lt; <span class="number">0.5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【逻辑回归】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://FF1204.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>机器学习-绪论-基本概念</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/机器学习-绪论-基本概念/</id>
    <published>2017-11-04T01:03:50.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="统计学习方法的三要素"><a href="#统计学习方法的三要素" class="headerlink" title="统计学习方法的三要素"></a>统计学习方法的三要素</h2><blockquote><p>方法 = 模型 + 策略 + 算法</p></blockquote><p><strong>模型</strong> 是方法依据的数学原理<br><strong>策略</strong> 是使用哪种损失函数或者代价函数<br><strong>算法</strong> 是如何如何求解问题</p><p>一个模型可以有多种策略(例如使用不同的损失函数度量损失的程度)， 一种策略可以有多种不同的方法(例如可以用梯度下降法，最小二乘法求解)。</p><h2 id="常用的模型"><a href="#常用的模型" class="headerlink" title="常用的模型"></a>常用的模型</h2><h2 id="常用的损失函数"><a href="#常用的损失函数" class="headerlink" title="常用的损失函数"></a>常用的损失函数</h2><h3 id="0-1-损失函数"><a href="#0-1-损失函数" class="headerlink" title="0-1 损失函数"></a>0-1 损失函数</h3><p>$$<br>L(Y,f(X)) = \begin{cases}<br>              1, &amp; { Y \neq f(X)} \<br>              0, &amp; { Y = f(X) }<br>              \end{cases}<br>$$</p><p><code>Y</code>表示实际的值，<code>f(X)</code>表示通过模型预测出来的值，0-1损失就是当预测正确的时候损失是0，预测错误的时候损失是1.</p><h3 id="绝对值损失函数"><a href="#绝对值损失函数" class="headerlink" title="绝对值损失函数"></a>绝对值损失函数</h3><p>$$<br>L(Y,f(X) = |Y - f(X)|<br>$$</p><h3 id="平方损失函数"><a href="#平方损失函数" class="headerlink" title="平方损失函数"></a>平方损失函数</h3><p>$$<br>L(Y,f(X)) = (Y - f(X))^2<br>$$</p><h3 id="对数损失函数"><a href="#对数损失函数" class="headerlink" title="对数损失函数"></a>对数损失函数</h3><p>$$<br>L(Y,P(Y|X)) = -logP(Y|X)<br>$$</p><h2 id="常用的算法"><a href="#常用的算法" class="headerlink" title="常用的算法"></a>常用的算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;统计学习方法的三要素&quot;&gt;&lt;a href=&quot;#统计学习方法的三要素&quot; class=&quot;headerlink&quot; title=&quot;统计学习方法的三要素&quot;&gt;&lt;/a&gt;统计学习方法的三要素&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;方法 = 模型 + 策略 + 算法&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://FF1204.github.io/hexoblog/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/"/>
    <id>http://FF1204.github.io/hexoblog/技术/数据库/SQL/</id>
    <published>2017-11-02T06:15:52.000Z</published>
    <updated>2019-08-01T02:24:50.502Z</updated>
    
    <content type="html"><![CDATA[<p>基于MySQL的语法说明数据库查询的一些操作。</p><p>在<code>test</code>数据库中创建一个<code>user</code>表，执行一些查询操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6Li Xiao102017-11-01</span><br><span class="line">7Li Xiao202017-11-02</span><br><span class="line">8Li Xiao102017-11-03</span><br><span class="line">9Zhao Hi202016-10-11</span><br><span class="line">10Zhao Hi202016-10-12</span><br><span class="line">11Zhao Hi202016-10-13</span><br><span class="line">12Kao Ha102016-03-01</span><br><span class="line">13Kao Ha202016-03-02</span><br><span class="line">14Cao Pi502016-09-11</span><br><span class="line">15Cao Pi102016-09-12</span><br></pre></td></tr></table></figure><a id="more"></a><ol><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>显示数据库中的表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果已经存在<code>user</code>表，删除它</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    price <span class="built_in">numeric</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">    update_time <span class="built_in">date</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建表的时候基本语法是： 列名 类型 [约束]，</p><p>约束是可选的，可用的约束有：</p><ul><li>unique  唯一值</li><li>not null 不能为空</li><li>default 默认值  添加默认值</li><li>check 满足某一个条件</li><li>primary key 指定为主键</li><li>foreign key 指定外键</li></ul><p>只约束某一列的时候，可以直接写在某个列上，如果涉及多个列，要写在最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    price <span class="built_in">numeric</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">    update_time <span class="built_in">date</span>,</span><br><span class="line">    <span class="keyword">check</span> (<span class="keyword">id</span> &gt; <span class="number">0</span> <span class="keyword">and</span> price &gt; <span class="number">0</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="5"><li>插入值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>, price , update_time) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.0</span>,<span class="string">'2017-11-01'</span>);</span><br></pre></td></tr></table></figure><p>指定自动增长的列和没有设置非空约束的列可以没有对应的值，会自动添加对应的数据。指定非空的列在插入的时候必须有值。</p><ol start="6"><li>更新值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> update_time = <span class="keyword">curdate</span>() <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'Li Xiao'</span>;</span><br></pre></td></tr></table></figure><ol start="7"><li>删除值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'Li Xiao'</span>;</span><br></pre></td></tr></table></figure><p>完整的创建数据库和插入需要的数据的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  price <span class="built_in">numeric</span> <span class="keyword">default</span> <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">date</span> <span class="built_in">date</span> </span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.2</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">80.0</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Li Xiao'</span>,<span class="number">10.0</span>,<span class="keyword">curdate</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-10-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-6-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Zhao Hi'</span>,<span class="number">20.0</span>,<span class="string">'2016-3-6'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Kao Ha'</span>,<span class="number">10.0</span>,<span class="string">'2016-3-5'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Kao Ha'</span>,<span class="number">20.0</span>,<span class="string">'2016-3-7'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Cao Pi'</span>,<span class="number">50.0</span>,<span class="string">'2016-9-10'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (<span class="keyword">name</span>,price,<span class="built_in">date</span>) <span class="keyword">values</span> (<span class="string">'Cao Pi'</span>,<span class="number">10.0</span>,<span class="string">'2016-2-10'</span>);</span><br></pre></td></tr></table></figure><ol start="8"><li>查询</li></ol><p>每个人的总额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> total <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>每个人的记录数量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">count</span>(*) <span class="keyword">as</span> nums <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>每个人的平均值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">avg</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>总的金额</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>每个人每次得到的钱占总共金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, price / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>每个人得到的钱的和占总金额的百分比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>输出记录数量大于2且总金额大于90的人的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">sum</span>(price) &gt; <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>输出2016年每个人得到的金额 占 2016 年总金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) / (<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) = <span class="number">2016</span>) <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) = <span class="number">2016</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p>输出每一年 每个人得到的总金额 占当年总金额的百分比</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 获得每个人在一年总的收入金额</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 获得每一年总的金额</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>);</span><br><span class="line">3. 两个表连接</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.name, a.price, b.sum, a.year <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)) <span class="keyword">as</span> a, (<span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>)) <span class="keyword">as</span> b <span class="keyword">where</span> a.year = b.year;</span><br><span class="line"></span><br><span class="line">4. 查询连接之后的表得到结果</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, price / <span class="keyword">sum</span> <span class="keyword">as</span> <span class="keyword">percent</span> <span class="keyword">from</span> (<span class="keyword">select</span> a.name, a.price, b.sum, a.year <span class="keyword">from</span> ((<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">sum</span>(price) <span class="keyword">as</span> price ,<span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>)) <span class="keyword">as</span> a, (<span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>) <span class="keyword">as</span> <span class="keyword">year</span> , <span class="keyword">sum</span>(price) <span class="keyword">as</span> <span class="keyword">sum</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span>)) <span class="keyword">as</span> b <span class="keyword">where</span> a.year = b.year) <span class="keyword">as</span> tmp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于MySQL的语法说明数据库查询的一些操作。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;test&lt;/code&gt;数据库中创建一个&lt;code&gt;user&lt;/code&gt;表，执行一些查询操作。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;6	Li Xiao	10	2017-11-01&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7	Li Xiao	20	2017-11-02&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8	Li Xiao	10	2017-11-03&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9	Zhao Hi	20	2016-10-11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10	Zhao Hi	20	2016-10-12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11	Zhao Hi	20	2016-10-13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12	Kao Ha	10	2016-03-01&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13	Kao Ha	20	2016-03-02&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14	Cao Pi	50	2016-09-11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15	Cao Pi	10	2016-09-12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="http://FF1204.github.io/hexoblog/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>KNN with C++</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN-with-C/"/>
    <id>http://FF1204.github.io/hexoblog/技术/机器学习/KNN-with-C/</id>
    <published>2017-10-15T14:27:57.000Z</published>
    <updated>2019-08-01T02:24:50.582Z</updated>
    
    <content type="html"><![CDATA[<p>KNN 算法步骤：</p><ul><li>存储训练集的特征和标签，确定K</li><li>预测一个未知的样本的时候，计算该样本到每一个训练集中的样本的距离，取前K个距离的最小值</li><li>在前K个最小值中选择标签出现次数最大的那个，作为预测结果</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> feature_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; trainSet;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trainLabel;</span><br><span class="line">    <span class="comment">// 特征向量之间的距离，修改这里使用不同的距离度量</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  返回两个点的距离</span></span><br><span class="line">        <span class="keyword">if</span>(a.size() != b.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)&#123;</span><br><span class="line">            sum += (a[i] - b[i]) * (a[i] - b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="built_in">sqrt</span>(sum);</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KNN() : k(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 创建类的时候保存训练集的特征和标签数据</span></span><br><span class="line">    KNN(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt; features,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; labels)&#123;</span><br><span class="line">        <span class="keyword">int</span> samples = features.size();</span><br><span class="line">        <span class="keyword">if</span>(samples != labels.size())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;trainSet = features;</span><br><span class="line">        <span class="keyword">this</span>-&gt;trainLabel = labels;</span><br><span class="line">        <span class="keyword">if</span>(!features.empty()) feature_num = features[<span class="number">0</span>].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预测一个测试样例的标签</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(test.size() != <span class="keyword">this</span>-&gt;feature_num) <span class="keyword">throw</span> <span class="keyword">new</span> exception();</span><br><span class="line">        <span class="comment">// 求test到训练集合中所有点的距离，找出距离最小的K个值</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">double</span>,<span class="keyword">int</span>&gt;&gt;,lessThan&gt; maxHeap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;trainSet.size();i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> dis = <span class="keyword">this</span>-&gt;distance(trainSet[i],test);</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() &lt; <span class="keyword">this</span>-&gt;k)&#123;</span><br><span class="line">                maxHeap.push(make_pair(dis,trainLabel[i]));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis &lt; maxHeap.top().first)&#123;</span><br><span class="line">                    maxHeap.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计K个点的类别标签，找到出现次数最多的那个标签</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cc; <span class="comment">// 统计每个类别从出现的次数 kye</span></span><br><span class="line">        <span class="keyword">while</span>(!maxHeap.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cc.count(maxHeap.top().second) == <span class="number">0</span>)&#123;</span><br><span class="line">                cc[maxHeap.top().second] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cc[maxHeap.top().second]++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxHeap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxV = INT32_MIN;</span><br><span class="line">        <span class="keyword">int</span> label = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter= cc.begin();iter != cc.end(); iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second &gt; maxV)&#123;</span><br><span class="line">                maxV = iter-&gt;second;</span><br><span class="line">                label = iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预测一个测试样例的标签</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">predict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; test, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;predict(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Kmeans 算法步骤</p><ul><li>在数据集中随机选择K个点</li><li>计算所有的点到K个中心点的距离，距离哪个中心点近，就标记成哪个中心点所属的列别</li><li>计算每个团的新的中心，</li><li>计算新的中心和上次的中心的差距</li><li>如果差距大，就继续循环，否则退出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MINVALUE = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">feature</span>&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> label; <span class="comment">// 属于哪一个聚类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kmeans</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 从[start,end] 产生 count 个随机数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random(<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> count)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(feature &amp;a, feature &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> cycle = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cluster</span><span class="params">(<span class="built_in">vector</span>&lt;feature&gt; dataset)</span></span>&#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random3 = random(<span class="number">0</span>,dataset.size()<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">         <span class="built_in">vector</span>&lt;feature&gt; centers;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;random3.size();i++)&#123;</span><br><span class="line">             dataset[i].label = i;</span><br><span class="line">             centers.push_back(dataset[i]);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(cycle--) &#123;</span><br><span class="line">             <span class="comment">// 标记所有点的所属聚簇</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataset.size(); i++) &#123;</span><br><span class="line">                 <span class="keyword">double</span> minDistance = INT32_MAX;</span><br><span class="line">                 <span class="keyword">int</span> label = <span class="number">-1</span>;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; random3.size(); j++) &#123;</span><br><span class="line">                     <span class="keyword">double</span> dis = distance(dataset[i], dataset[random3[j]]);</span><br><span class="line">                     <span class="keyword">if</span> (dis &lt; minDistance) &#123;</span><br><span class="line">                         minDistance = dis;</span><br><span class="line">                         label = j;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 dataset[i].label = label;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 更新每个聚簇的中心</span></span><br><span class="line">             <span class="built_in">vector</span>&lt;feature&gt; newCenters(centers);</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dataset[<span class="number">0</span>].v.size(); j++) &#123;</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sum(k, <span class="number">0.0</span>);</span><br><span class="line">                 <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cc(k, <span class="number">0</span>);</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataset.size(); i++) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; k; p++) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (dataset[i].label == p) &#123;</span><br><span class="line">                             sum[p] += dataset[i].v[j];</span><br><span class="line">                             cc[p]++;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                     sum[i] = sum[i] / cc[i];</span><br><span class="line">                     newCenters[i].v.push_back(sum[i]);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 计算和上次中心的差距，差距在一定范围内就退出,centers, newcenters 之间的差距</span></span><br><span class="line">             <span class="keyword">double</span> dis = <span class="number">0.0</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                 dis += distance(newCenters[i], centers[i]);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (dis &lt; MINVALUE) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cluster</span><span class="params">(<span class="built_in">vector</span>&lt;feature&gt; dataset,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cluster(dataset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;KNN 算法步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储训练集的特征和标签，确定K&lt;/li&gt;
&lt;li&gt;预测一个未知的样本的时候，计算该样本到每一个训练集中的样本的距离，取前K个距离的最小值&lt;/li&gt;
&lt;li&gt;在前K个最小值中选择标签出现次数最大的那个，作为预测结果&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="机器学习" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="KNN" scheme="http://FF1204.github.io/hexoblog/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>大数据基础框架</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/"/>
    <id>http://FF1204.github.io/hexoblog/技术/大数据/大数据基础框架/</id>
    <published>2017-10-06T12:21:59.000Z</published>
    <updated>2019-08-01T02:24:50.486Z</updated>
    
    <content type="html"><![CDATA[<p>大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。</p><a id="more"></a><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p><code>hadoop distributed file system (HDFS)</code> 是脱胎于<code>google file system</code>的一个分布式文件系统,据说，其性能并没有达到GFS的水平，只是根据谷歌论文的原理的一个开源实现版本。 HDFS的特定有以下几点：</p><ol><li>同时保存多个副本(默认三个)，提供容错机制，副本丢失能够自动恢复。</li><li>运行在不可靠机器上(廉价机器上)</li><li>适合大数据的处理，HDFS默认将文件分成64M大小的block, 将block按照键值对的方式存储在HDFS上。将映射关系保存在内存中。</li></ol><h3 id="HDFS的构成"><a href="#HDFS的构成" class="headerlink" title="HDFS的构成"></a>HDFS的构成</h3><p><code>HDFS</code>是主从结构(<code>master/slave</code>结构)，主要由<code>NameNode</code>和<code>DataNode</code>组成。<code>NameNode</code> 是Master节点，负责整个系统的结构信息和调度控制，<code>DataNode</code>是slave节点，负责存储数据。除此之外，一般还有一个<code>SecondaryNameNode</code>节点，是<code>NameNode</code>节点的备份，负责承担一部分<code>NameNode</code>的工作，定时备份<code>NameNode</code>的数据，当<code>NameNode</code>出现故障的时候，可以从<code>SecondaryNameNode</code>恢复数据。</p><ul><li>NameNode</li><li>DataNode</li></ul><h3 id="写文件操作"><a href="#写文件操作" class="headerlink" title="写文件操作"></a>写文件操作</h3><p><img src="26162921-2de9d28df9b54fe6a97a6fd88f1cb03f.jpg" alt="HDFS写文件示意图"></p><p>如上图，该图表示一个win7系统的电脑要把一个100M的文件写入一个HDFS文件系统。该HDFS文件系统运行在一个Hadoop集群之上，集群拥有一个NameNode(NN)节点，8个DataNode(DN)节点，有三个机架(rack1,rack2,rack3), 全部在一个机房内。</p><ol><li><p>client把文件分割程64M大小(HDFS文件系统的默认大小)，生成两个文件块，一个64M， 一个36M。</p></li><li><p>client向NameNode发送写文件的请求。</p></li><li><p>NameNode收到请求之后，查询自己数据中记录的整个HDFS文件系统的信息，确定这些数据写入哪些DataNode节点中，并且记录下该信息，返回该信息给请求的主机。</p></li></ol><blockquote><p>假设分配的情况如下：</p></blockquote><blockquote><ul><li>block1: host2,host1,host3</li><li>block2: host7,host8,host4</li></ul></blockquote><blockquote><p>分配DataNode节点的规则为： 如果client为DataNode节点，那么副本1存储在与client相同的节点上，副本2存储在不同机架的节点上，副本三存储在同副本2相同机架上的不同节点； 如果client不是DataNode节点，则副本1随机选择一个节点，副本2选择不同的机架，副本3同副本2的机架的不同节点。</p></blockquote><ol start="4"><li><p>client根据收到的写入信息,把block1写入第一个主机host2, 整个写入过程是流式写入的，数据被分割策划那个64K的小数据包写入，每次写完64K，host2将自己刚刚得到的64K数据写入host1, host1得到64K之后写入host3, 实际上客户端只需要向host2写入一次数据，数据就可以有三个备份。当第一个block写完之后，host2,host1,host3向NameNode, host2向client发送信息说明数据已经写完。</p></li><li><p>client收到信息之后发送第二个block，过程和第一个block一样。</p></li><li><p>第二个block写完之后，数据彻底写完，写文件的过程就结束了。</p></li></ol><p>通过写文件的过程和不同副本的分配策略可以看出，挂掉一个节点设置整个机架都是没有关系的，总能从其他的地方找回这些丢失的数据。</p><h3 id="读文件操作"><a href="#读文件操作" class="headerlink" title="读文件操作"></a>读文件操作</h3><p><img src="26163017-fc613879835c402886b75e0593ca52ed.jpg" alt="HDFS读取文件示意图"></p><p>如图，win7客户端要从HDFS文件系统上读取一个100M大小的的文件，该文件在HDFS中有两个数据块组成:block1,block2.</p><ol><li><p>client 向NameNode 发送读取文件的请求。</p></li><li><p>NameNode收到读取文件的请求，查询自己存储的元信息，返回block1和block2的存储位置： <code>block1: host2,host1,host3; block2: host7,host8,host4</code>;</p></li><li><p>客户端收到NameNode的消息，去机器host2读取block1,去机器host7读取block2,读取完成之后合并成一个完整的文件，整个读文件的过程就结束了。如果client位于DataNode内，则优先读取本机架上的数据。</p></li></ol><p>参考文献：<a href="http://www.cnblogs.com/laov/p/3434917.html" target="_blank" rel="noopener">HDFS读写原理</a></p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce 是一个计算框架，就是在特定的输入上产生特定的输出。输入和输出都是<code>&lt;key,val&gt;</code>这种键值对的形式。 Mapper就是对每个个体进行操作，不涉及个体之间的相互作用，例如转换格式，分割字符串等，这样Mapper这个阶段做的工作可以在许多机器上并行的执行， Reducer执行一些需要不同条目之间协同才能完成的操作，例如计数，求和，需要遍历所有的条目才能得到结果。Reducer任务会在不同的机器上传递结果，得到最终的结果之后再返回。</p><p><img src="x.png" alt="MapReduce运行机制"></p><ol><li><p>在执行Map计算之前，先要根据文件的大小和HDFS的配置情况进行分片(input split), 假设HDFS默认的block大小是64M，而本次任务的输入有3个文件，一个10M，一个70M，一个128M，则10M的文件会被分成一片，70M的文件会被分成两片，128M的文件也会被分成两片。 分片操作仅仅计算出一个分片的长度和每个分片对应的数据的索引位置，并不改变原来的数据。</p></li><li><p>执行程序中定义好的Map操作，Map在各个数据节点上独立的执行，相互之间没有影响。</p></li><li><p>combiner阶段：目的是在本地机器上执行reduce操作，把可以在本地机器上合并的结果先执行了，避免以后需要大量传输数据(机器之间传输数据 的开销往往是分布式系统最大的瓶颈). 例如求最大值，最小值和求和等操作，可以Map之后可以现在各个数据节点求出整个数据节点的最大值，作为一个结果输出，之后的reduce操作会大大减少结果的传输负担。</p></li><li><p>shuffle阶段： 将Mapper阶段的输出作为Reducer阶段的输入数据。</p></li><li><p>Reduce阶段： 执行用户编写的reduce函数，得出结果之后存储在HDFS文件系统之上。</p></li></ol><p><img src="1.png" alt="Map-Shuffle-Reduce过程解析"></p><p>参考文献:<a href="http://www.cnblogs.com/sharpxiajun/p/3151395.html" target="_blank" rel="noopener">cnblogs</a></p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><h3 id="弹性分布式数据集-RDD"><a href="#弹性分布式数据集-RDD" class="headerlink" title="弹性分布式数据集(RDD)"></a>弹性分布式数据集(RDD)</h3><p>Spark 底层存储数据的时候使用的是Hadoop的HDFS分布是文件系统，所以可以存储任何兼容Hadoop的数据源，例如Hbase. Spark 在逻辑上把数据存储在一个一个的RDD中，一个RDD可以看作一张表格，可以保存任何类型的数据。RDD是不可改变的，任何改变RDD的操作都会返回一个全新的RDD，spark的所有操作，在逻辑上都是针对RDD的操作。 RDD支持两种操作：transformation 和 action . transformation 是对RDD执行一个变换操作，不会立即计算，只是记录了应该在该RDD上执行这样的操作。 action 一般会是一个reduce操作， 会立刻执行，就是之前定义的所有transformation操作和当前定义的action操作。</p><ul><li><p><strong>transformation</strong>: 对RDD执行一个变换，返回一个新的RDD。可用的操作有map,filter,flatMap, groupByKey, reduceByKey 等。</p></li><li><p><strong>action</strong>: 在该RDD对象上执行之前定义的所有操作(包括所有的transformation操作)， 返回计算的结果。 可用的操作有reduce, collect, count, first, countByKey 等。</p></li></ul><h3 id="WordCount-程序"><a href="#WordCount-程序" class="headerlink" title="WordCount 程序"></a>WordCount 程序</h3><p>使用spark运行一个统计单词个数的程序十分简单，这个过程可以帮助我们了解spark是如何工作的。</p><p>读取文本文件并生成RDD，将RDD缓存在内存中，缓存的RDD不需要从头开始计算，如果RDD没有缓存，就算过后的RDD会被立刻丢弃，每次想要得到结果都需要从头开始计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SimpleApp.scala */</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkContext</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkContext._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf</span><br><span class="line"></span><br><span class="line">object SimpleApp &#123;</span><br><span class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span> </span>&#123;</span><br><span class="line">    val logFile = <span class="string">"YOUR_SPARK_HOME/README.md"</span> <span class="comment">// 应该是你系统上的某些文件</span></span><br><span class="line">    val conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"Simple Application"</span>)</span><br><span class="line">    val sc = <span class="keyword">new</span> SparkContext(conf)</span><br><span class="line">    val logData = sc.textFile(logFile, <span class="number">2</span>).cache()</span><br><span class="line">    val numAs = logData.filter(line =&gt; line.contains(<span class="string">"a"</span>)).count()</span><br><span class="line">    val numBs = logData.filter(line =&gt; line.contains(<span class="string">"b"</span>)).count()</span><br><span class="line">    println(<span class="string">"Lines with a: %s, Lines with b: %s"</span>.format(numAs, numBs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序仅仅是在 Spark README 中计算行里面包含 ‘a’ 和包含 ‘b’ 的次数.</p><h3 id="Spark-框架的主要内容"><a href="#Spark-框架的主要内容" class="headerlink" title="Spark 框架的主要内容"></a>Spark 框架的主要内容</h3><p><img src="spark-stack-new.png" alt="Spark生态系统"></p><ul><li><p><code>spark streaming</code> : 基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</p></li><li><p><code>spark SQL</code> : 可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。</p></li><li><p><code>spark mlib</code> : 是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。</p></li><li><p><code>spark graphx</code> : 是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。</p></li><li><p><code>blinkDB</code> : 一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。</p></li><li><p><code>sparkR</code> : R语言的spark接口</p></li></ul><h2 id="HBASE"><a href="#HBASE" class="headerlink" title="HBASE"></a>HBASE</h2><p>HBase, Hadoop Database, 是Google Bigtable的开源实现，是一个面向列的，可伸缩的分布式存储系统，它的底层文件存储使用的是HDFS。</p><p><strong><code>HBase</code>的存储逻辑</strong></p><p>表由行和列组成，列被分组，若干个列组成一个列簇（row family）,表在定义的时候，就必须声明所有的列簇，但是列簇内包含几个列可以动态增加(这也体现了面向列的存储这一方面). 同一个列簇使用相同的前缀为其命名，例如<code>temperature:air</code> 和  <code>temperature:dew</code> 都是<code>temperature</code>列簇的成员, <code>HBase</code>的每个列簇称作一个<code>store</code>，同一个列簇的数据会存储在同一个目录下，可能会分割成多个文件存储。</p><p>每个行由一个键表示，行键是一个字节数组，行按照行键进行排序。</p><p>行列交叉的位置称作<code>Cell</code>，每个cell都有版本，以时间戳标识，这个标识可以自己定义。也就是说，Hbase中的每个数据都是有版本的，数据按照时间倒序排列，最新的数据排列在最前面。cell中的内容是字节数组，不带格式,HBase存储的数据都是无格式的。唯一的确定一个cell需要下面这些数据：row key(行键), column:label(列簇的前缀的列的名称)， version(版本号)， 行键用来确定是哪一行，column:label确定是哪一列，版本号确定是哪个版本的数据，这样可以唯一的确定一个单元格里的数据。</p><p>HBase自动把表格水平划分程若干region, 每个region都是连续的若干行数据(类似数据库的水平分割).</p><p><strong>HBase的物理存储结构</strong></p><p>一个Table最初只有一个Region,随这行的数量的增加，当超过一个既定的阈值的时候，Region就会等分为2个。 相同的Region保证存储在相同的机器上，不同的Region可以存储在不同的机器上，叫做region server。</p><p>每个Region存储的若干行和这些行的所有列。每个Region的内部存储是这样的：Region 由一个或者多个store组成，每个store存储一个列簇， 每个store包括一个memStore和0个或者多个storefile,storefile是存储的最小单位，以HFile的格式保存在HDFS文件系统上。</p><p><img src="QQ截图20171007212611.png" alt="HBase架构示意图"></p><p><strong>HBase的运行</strong></p><p>HBase 由一个主节点master和若干个RegionServer组成，主节点的负载较轻，主要负责引导初始安装，分配区域给已经注册的区域服务器，恢复区域服务器的故障等。 区域服务器负责自己存储的若干个区域的读写工作。</p><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析</p><p>Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作</p><p>简单来讲，Hive提供了一种高级的类似SQL的语言，来执行一些以前必须要自己写Map,Reduce程序才能实现的功能，大大简化了数据处理的难度(MapReduce程序很难写)， 但是，Hive的实时性很差，适合离线处理，数据分析和数据挖掘等对实时性要求不高的任务。</p><h2 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h2><p>提供类似SQL的语言叫做<code>Pig Latin</code>, 可以把类SQL的语言转化程优化处理过的MapReduce运算。</p><p>Pig是一种大规模数据集的脚本语言，它实际上提供了一整套脚本语言的特性，用来处理海量的数据。</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper的目的是提供一些工具集，用来建立安全处理局部故障的分布式应用。 使用Zookeeper, 我们可以更容易的自己实现一个分布式的应用。</p><p>参考文献:<a href="http://www.cnblogs.com/wuxl360/p/5817471.html" target="_blank" rel="noopener">1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="大数据" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="HDFS" scheme="http://FF1204.github.io/hexoblog/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_常见题目</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/"/>
    <id>http://FF1204.github.io/hexoblog/技术/数据结构和算法/算法专题-常见题目/</id>
    <published>2017-10-03T03:06:18.000Z</published>
    <updated>2019-08-01T02:24:50.510Z</updated>
    
    <content type="html"><![CDATA[<p>【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】</p><a id="more"></a><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的压入弹出序列"><a href="#栈的压入弹出序列" class="headerlink" title="栈的压入弹出序列"></a><a href="https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">栈的压入弹出序列</a></h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="132序列"><a href="#132序列" class="headerlink" title="132序列"></a><a href="http://lintcode.com/zh-cn/problem/132-pattern/#" target="_blank" rel="noopener">132序列</a></h3><p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p><p>n will be less than 20,000.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> third = INT32_MIN; <span class="comment">// 中间大的数</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 如果找到小于第二大的数字，则小于第二大的数字，第二大的数字和最大的数字三个数字都找到，返回true;</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; third) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前数字大于栈顶元素，则找到了第二大的数字(栈顶元素)，最大的数字变成了当前数字</span></span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123;</span><br><span class="line">                third = s.top(); s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list/" target="_blank" rel="noopener">翻转链表</a></h3><p>翻转一个链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode * head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并K个链表"><a href="#合并K个链表" class="headerlink" title="合并K个链表"></a><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个链表</a></h3><p>合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/" target="_blank" rel="noopener">复杂链表的复制</a></h3><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。</p><p>返回一个深拷贝的链表。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a><a href="http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#" target="_blank" rel="noopener">链表求和</a></h3><p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">addLists2</span><span class="params">(ListNode * l1, ListNode * l2)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的中间节点"><a href="#链表的中间节点" class="headerlink" title="链表的中间节点"></a>链表的中间节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到链表的中间节点并返回</span></span><br><span class="line"><span class="comment"> * @param head</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *first = head, *second = head;</span><br><span class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</span><br><span class="line">        first = first-&gt;next;</span><br><span class="line">        second = second-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="前序遍历的非递归实现"><a href="#前序遍历的非递归实现" class="headerlink" title="前序遍历的非递归实现"></a><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="noopener">前序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</span><br><span class="line">      <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历的非递归实现"><a href="#中序遍历的非递归实现" class="headerlink" title="中序遍历的非递归实现"></a><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="noopener">中序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode * root) &#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历的非递归实现"><a href="#后序遍历的非递归实现" class="headerlink" title="后序遍历的非递归实现"></a><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="noopener">后序遍历的非递归实现</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode * root) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树的最大深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="noopener">二叉树的最小深度</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write your code here</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="叶子之间的最长距离"><a href="#叶子之间的最长距离" class="headerlink" title="叶子之间的最长距离"></a>叶子之间的最长距离</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="TOP-K"><a href="#TOP-K" class="headerlink" title="TOP K"></a>TOP K</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="noopener">数据流的中位数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; medianII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="第K大的数"><a href="#第K大的数" class="headerlink" title="第K大的数"></a><a href="http://lintcode.com/zh-cn/problem/kth-largest-element/" target="_blank" rel="noopener">第K大的数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a><a href="http://lintcode.com/zh-cn/problem/median/#" target="_blank" rel="noopener">中位数</a></h3><p>给定一个未排序的整数数组，找到其中位数。</p><p>中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="数组的逆序对的个数"><a href="#数组的逆序对的个数" class="headerlink" title="数组的逆序对的个数"></a><a href="http://lintcode.com/zh-cn/problem/reverse-pairs/" target="_blank" rel="noopener">数组的逆序对的个数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><a href="http://lintcode.com/zh-cn/problem/strstr/" target="_blank" rel="noopener">KMP算法</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">const</span> <span class="keyword">char</span> *target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="出现一半以上的数"><a href="#出现一半以上的数" class="headerlink" title="出现一半以上的数"></a>出现一半以上的数</h3><p>一个数组中有一个数字的出现次数超过一半(超过50%),求出这个数字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMajority</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组跳跃能否达到终点"><a href="#数组跳跃能否达到终点" class="headerlink" title="数组跳跃能否达到终点"></a>数组跳跃能否达到终点</h3><p>一个整形数组，每个元素代表可以在当前位置的基础上向后跳跃几步，问要跳跃到最后最少需要跳跃几步，如果不能到达最后返回-1;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://FF1204.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>手写代码-其他</title>
    <link href="http://FF1204.github.io/hexoblog/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81-%E5%85%B6%E4%BB%96/"/>
    <id>http://FF1204.github.io/hexoblog/技术/数据结构和算法/手写代码-其他/</id>
    <published>2017-09-27T15:12:30.000Z</published>
    <updated>2019-08-01T02:24:50.510Z</updated>
    
    <content type="html"><![CDATA[<p>【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】</p><a id="more"></a><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = v.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] == val) <span class="keyword">return</span> mid;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] &gt; val)&#123;</span><br><span class="line">           j = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(v[mid] &lt; val)&#123;</span><br><span class="line">         i = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有重复的val,返回val的起始位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binaryResearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = v.size() <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mind;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j))&#123;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] == val)&#123;</span><br><span class="line">        <span class="keyword">while</span>(v[mid] == val &amp;&amp; mid &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          mid--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] &gt; val)&#123;</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(v[mid] &lt; val)&#123;</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v.size()<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt; v[i+<span class="number">1</span>]) swap(v[i],v[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">static</span> Single* instance = null; <span class="comment">// 静态私有变量，属于类</span></span><br><span class="line">      Singleton()&#123;&#125;</span><br><span class="line">      Singleton(<span class="keyword">const</span> Singleton&amp;)&#123;&#125;</span><br><span class="line">      Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)&#123;&#125; <span class="comment">// 防止赋值的时候拷贝</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">static</span> Singleton* getInstance() <span class="comment">// 静态方法，确保使用类可以调用</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">             lock(); <span class="comment">// 线程安全的写法，如果不用确保线程安全，不需要</span></span><br><span class="line">             <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                 instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">             &#125;</span><br><span class="line">             unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>// 使用方法<br><code>auto instance = Singleton::getInstance();</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据结构和算法" scheme="http://FF1204.github.io/hexoblog/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://FF1204.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
</feed>
